<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>gpg</title>
		<style>
			* {
				box-sizing: border-box;
			}
			html,body {
				width: 100%;
				height: 100%;
			}
			body {
				margin: 0;
				display: flex;
				align-items: center;
				justify-content: center;
				overflow: hidden;
			}
			#canvas {
				width: 100vh;
				height: 100vh;
				outline: 2px solid blue;
			}
			#tooltip {
				background-color: #FFFFFF;
				border: 1px solid #AAAAAA;
				border-radius: 5px;
				color: black;
				font-family: Arial, Helvetica, sans-serif;
				position: absolute;
				top: 0px;
				left: 0px;
				pointer-events: none;
				padding: 2px;
				display: none;
			}
			input[type="range"] {
				width: 600px;
			}
		</style>
	</head>
	<body>
		<div>
			<input type="range" id="samples" min="1" max="20" step="1"><br>
			<input type="range" id="iterations" min="1" max="250" step="1">
		</div>
		<canvas id="canvas"></canvas>
		<div id="tooltip">asd</div>
	</body>
	<script id="vertex" type="x-shader/x-vertex">
		attribute vec2 a_position;

		void main() {
			gl_Position = vec4(a_position, 0, 1); // vec4(u_matrix * vec3(a_position, 1), 1);
		}
	</script>
	<script id="fragment" type="x-shader/x-fragment">
		precision highp float;

		uniform vec2 u_screenSize;
		uniform vec2 u_scale;
		uniform vec2 u_offset;
		uniform float u_samples;
		uniform float u_iterations;

		bool lineEquals(float a, float b, float width) {
			return b < a + width / 2.0 && b > a - width / 2.0;
		}
		bool menger(float x, float y, float radius, float iterations) {
			bool is = max(abs(x), abs(y)) < radius;
			for (float i = 1.0; i < 250.0; i++) {
				if (i >= iterations) {
					break;
				}
				is = is ^^ max(abs(x), abs(y)) < radius / i;
			}
			return is;
		}
		bool testCoordinate(float x, float y) {
			/*highp float height = 0.0;
			for (highp float n = -8.0; n < 30.0; n++) {
				if (n >= u_samples) break;
				height += sin(pow(2.0, n) * x) / pow(2.0, n);
			};*/
			return menger(x, y, 10.0, u_iterations);// < height + cos(x / 1200.0) * 1200.0;
		}
		vec4 vec4Lerp(vec4 a, vec4 b, float t) {
			return (b - a) * t + a;
		}
		float log10(float x) {
			return log(x) / log(10.0);
		}
		float roundUp(float x) {
			return pow(10.0, ceil(log10(x)));
		}
		float roundDown(float x) {
			return pow(10.0, floor(log10(x)));
		}
		void main() {
			highp float x = (gl_FragCoord.x - u_screenSize.x / 2.0) * u_scale.x + u_offset.x;
			highp float y = (gl_FragCoord.y - u_screenSize.y / 2.0) * u_scale.y + u_offset.y;
			vec4 color = vec4(1.0);
			float avgBrightness = 0.0;
			float aaX = 0.0;
			float aaY = 0.0;
			for (float aaX = 0.0; aaX < 1.0; aaX += 1.0 / 3.0) {
				for (float aaY = 0.0; aaY < 1.0; aaY += 1.0 / 3.0) {
					avgBrightness += testCoordinate(x + aaX * u_scale.x, y + aaY * u_scale.y) ? 1.0 : 0.0;
				}
			}
			avgBrightness /= pow(3.0, 2.0);
			color = vec4Lerp(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0, 0.8, 0.0, 1.0), avgBrightness);
			if ((x / u_scale.x > -1.0 && x / u_scale.x < 1.0) || (y / u_scale.y > -1.0 && y / u_scale.y < 1.0)) {
				color = vec4Lerp(color, vec4(0.5, 0.5, 0.5, 1.0), 0.75);
			} else {
				float scaleUp = roundUp(u_scale.x) * 10.0;
				if (mod(x, scaleUp) < 2.0 * u_scale.x || mod(y, scaleUp) < 2.0 * u_scale.y) {
					color = vec4Lerp(color, vec4(0.5, 0.5, 0.5, 1.0), 0.1);
				} else if (mod(x, scaleUp / 10.0) < 2.0 * u_scale.x || mod(y, scaleUp / 10.0) < 2.0 * u_scale.y) {
					color = vec4Lerp(color, vec4(0.5, 0.5, 0.5, 1.0), 0.05);
				} else if (mod(x, scaleUp * 10.0) < 2.0 * u_scale.x || mod(y, scaleUp * 10.0) < 2.0 * u_scale.y) {
					color = vec4Lerp(color, vec4(0.5, 0.5, 0.5, 1.0), 0.2);
				}
			}
			gl_FragColor = color;
		}
	</script>
	<script>
		function lerp(a, b, c) {
			return (b - a) * c + a;
		};
		const canvas = document.getElementById("canvas");
		canvas.width = innerHeight;
		canvas.height = innerHeight;
		const gl = canvas.getContext("webgl");
 
		gl.viewport(0, 0, canvas.width, canvas.height);
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT);
		
		// get shader code
		var vertexCode = document.getElementById("vertex").firstChild.nodeValue;
		var fragmentCode = document.getElementById("fragment").firstChild.nodeValue;

		// create shaders and program
		var vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader, vertexCode);
		gl.compileShader(vertexShader);
		
		var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader, fragmentCode);
		gl.compileShader(fragmentShader);

		var program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);

		// stuffs
		var u_screenSizeLoc = gl.getUniformLocation(program, "u_screenSize");
		var u_scaleLoc = gl.getUniformLocation(program, "u_scale");
		var u_offsetLoc = gl.getUniformLocation(program, "u_offset");
		var u_samplesLoc = gl.getUniformLocation(program, "u_samples");
		var u_iterationsLoc = gl.getUniformLocation(program, "u_iterations");

		// errors
		if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(vertexShader));
		};
		if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(fragmentShader));
		};
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			alert(gl.getProgramInfoLog(program));
		};
		gl.validateProgram(program);


		// vertexes and stuff

		var vertices = new Float32Array([
			-1, -1, 1, -1, -1, 1,
			-1, 1, 1, 1, 1, -1
		]);

		var vbuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);
		gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

		var itemSize = 2;
		var numItems = vertices.length / itemSize;

		gl.useProgram(program);

		var a_positionLoc = gl.getAttribLocation(program, "a_position");
		gl.enableVertexAttribArray(a_positionLoc);
		gl.vertexAttribPointer(a_positionLoc, itemSize, gl.FLOAT, false, 0, 0);

		var scale = 1;
		var offsetX = 0;
		var offsetY = 0;
		var mouseX = 0;
		var mouseY = 0;
		var mouseDown = false;
		var mouseButton = 1;
		var oldTime = 0;
		var deltaTime = 1;
		function zoom(e) {
			let oldScale = scale;
			let zoomAmount = 1.05;
			
			let rect = canvas.getBoundingClientRect();
			let coordAbs = coords(e.clientX - rect.left, e.clientY - rect.top, true);
			if (Math.sign(e.deltaY) === 1) {
				offsetX -= coordAbs.x;
				offsetY -= coordAbs.y;
				scale *= zoomAmount;
				let coord = coords(e.clientX - rect.left, e.clientY - rect.top, false);
				let deltaScale = scale - oldScale;
				offsetX += (coordAbs.x / zoomAmount) - deltaScale;
				offsetY += (coordAbs.y / zoomAmount) - deltaScale;
			} else {
				offsetX += coordAbs.x;
				offsetY += coordAbs.y;
				scale /= zoomAmount;
				let coord = coords(e.clientX - rect.left, e.clientY - rect.top, false);
				let deltaScale = scale - oldScale;
				offsetX -= (coordAbs.x / zoomAmount) - deltaScale;
				offsetY -= (coordAbs.y / zoomAmount) - deltaScale;
			};
		};
		function coords(x, y, absolute=false) {
			return {
				x: (x - canvas.width / 2) * scale + offsetX * !absolute,
				y: ((canvas.height - y) - canvas.height / 2) * scale + offsetY * !absolute
			};
		};
		function moveMouse(e) {
			var tooltip = document.getElementById("tooltip");
			var rect = canvas.getBoundingClientRect();
			tooltip.style.left = e.clientX + 13 + "px";
			tooltip.style.top = e.clientY + 16 + "px";
			mouseX = e.clientX;
			mouseY = e.clientY;
			var coord = coords(e.clientX - rect.left, e.clientY - rect.top, false);
			tooltip.innerText = "(" + coord.x.toFixed(3) + ", " + coord.y.toFixed(3) + ")";
		};
		function mouseEnter(e) {
			tooltip.style.display = "block";
		};
		function mouseLeave(e) {
			tooltip.style.display = "none";
		};
		function mouseDownFun(e) {
			mouseDown = true;
			mouseButton = e.which;
		};
		function mouseUpFun(e) {
			mouseDown = false;
		};
		function contextMenu(e) {
			e.preventDefault();
		};
		canvas.addEventListener("wheel", zoom);
		canvas.addEventListener("mousemove", moveMouse);
		canvas.addEventListener("mouseenter", mouseEnter);
		canvas.addEventListener("mouseleave", mouseLeave);
		canvas.addEventListener("mousedown", mouseDownFun);
		canvas.addEventListener("mouseup", mouseUpFun);
		canvas.addEventListener("contextmenu", contextMenu);
		function render() {
			var newTime = performance.now();
			deltaTime = newTime - oldTime;
			oldTime = newTime;
			if (mouseDown) {
				zoom({
					deltaY: mouseButton === 1 ? -1 : 1,
					clientX: mouseX,
					clientY: mouseY
				});
			};

			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.uniform2fv(u_screenSizeLoc, [canvas.width, canvas.height]);
			gl.uniform2fv(u_scaleLoc, [scale, scale]);
			gl.uniform2fv(u_offsetLoc, [offsetX, offsetY]);
			gl.uniform1f(u_samplesLoc, document.getElementById("samples").valueAsNumber);
			gl.uniform1f(u_iterationsLoc, document.getElementById("iterations").valueAsNumber);
			// draw stuff
			gl.drawArrays(gl.TRIANGLES, 0, numItems);
			requestAnimationFrame(render);
		};
		render();
	</script>
</html>
