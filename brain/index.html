<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Mouse Follower</title>
		<style>
			* {
				box-sizing: border-box;
			}
			html,body {
				width: 100%;
				height: 100%;
			}
			body {
				margin: 0;
				overflow: hidden;
			}
			#canvas-wrapper,#canvas {
				width: 100%;
				height: 100%;
				outline: none;
			}
		</style>
	</head>
	<body>
		<div id="canvas-wrapper" tabindex="0" onmousemove="mouseMove(event);" onkeypress="generation(event);">
			<canvas id="canvas"></canvas>
		</div>
	</body>
	<script>
		const canvas = document.getElementById("canvas");
		canvas.width = innerWidth;
		canvas.height = innerHeight;
		const ctx = canvas.getContext("2d");

		class Cube {
			constructor(brain) {
				this.x = 100;
				this.y = canvas.height / 2;
				this.brain = brain ?? new NeuralNetwork([numberOfRays, 10, 10, 10, 10, 4]); // distx, disty, mousexvel, mouseyvel
				this.dead = false;
			};
		};

		var mouseX = canvas.width / 2;
		var mouseY = canvas.height / 2;
		var mouseVelX = 0;
		var mouseVelY = 0;
		ctx.font = "16px monospace";

		class NeuralNetwork {
			constructor(neuronCounts) {
				this.levels = [];
				for (let i = 0; i < neuronCounts.length - 1; i++) {
					this.levels.push(new Level(
						neuronCounts[i], neuronCounts[i + 1]
					));
				};
			};

			static feedForward(givenInputs, network) {
				let outputs = Level.feedForward(
					givenInputs, network.levels[0]);
				for (let i = 1; i < network.levels.length; i++) {
					outputs = Level.feedForward(
						outputs, network.levels[i]);
				};
				return outputs;
			};

			static mutate(network, amount=1) {
				network.levels.forEach(level => {
					for (let i = 0; i < level.biases.length; i++) {
						level.biases[i] = lerp(
							level.biases[i],
							Math.random() * 2 - 1,
							amount
						);
					};
					for (let i = 0; i < level.weights.length; i++) {
						for (let j = 0; j < level.weights[i].length; j++) {
							level.weights[i][j] = lerp(
								level.weights[i][j],
								Math.random() * 2 - 1,
								amount
							);
						};
					};
				});
			};
		};

		class Level {
			constructor(inputCount, outputCount) {
				this.inputs = new Array(inputCount);
				this.outputs = new Array(outputCount);
				this.biases = new Array(outputCount);

				this.weights = [];
				for (let i = 0; i < inputCount; i++) {
					this.weights[i] = new Array(outputCount);
				};

				Level.#randomize(this);
			};

			static #randomize(level) {
				for (let i = 0; i < level.inputs.length; i++) {
					for (let j = 0; j < level.outputs.length; j++) {
						level.weights[i][j] = Math.random() * 2 - 1;
					};
				};

				for (let i = 0; i < level.biases.length; i++) {
					level.biases[i] = Math.random() * 2 - 1;
				};
			};

			static feedForward(givenInputs, level) {
				for (let i = 0; i < level.inputs.length; i++) {
					level.inputs[i] = givenInputs[i];
				};

				for (let i = 0; i < level.outputs.length; i++) {
					let sum = 0;
					for (let j = 0; j < level.inputs.length; j++) {
						sum += level.inputs[j] * level.weights[j][i];
					};

					if (sum > level.biases[i]) {
						level.outputs[i] = 1;
					} else {
						level.outputs[i] = 0;
					};
				};

				return level.outputs;
			};
		};
		//var cubeBrain = new NeuralNetwork( // distx, disty, mousexvel, mouseyvel
		//	[4, 6, 4]
		//);
		var cubes = [];
		var numberOfCubes = 300;
		var numberOfRays = 15;
		var pixels = [];
		var bestX = 0;
		for (let i = 0; i < numberOfCubes; i++) {
			cubes.push(new Cube());
		};

		function drawLevel() {
			ctx.fillStyle = "black";
			ctx.fillRect(0, 0, canvas.width, 10);
			ctx.fillRect(0, 0, 10, canvas.height);
			ctx.fillRect(canvas.width - 10, 0, 10, canvas.height);
			ctx.fillRect(0, canvas.height - 10, canvas.width, 10);

			ctx.fillRect(400, 0, 400, 600);
			ctx.strokeStyle = "black";
			ctx.lineWidth = 17
			drawLine([845, 713], [1430, 400]);
			drawLine([790, 593], [1238, 354]);
			drawLine([1427, 397], [1200, 60]);
			drawLine([1232, 355], [1063, 123]);
			ctx.fillRect(1189, 377, 15, 50);
			ctx.fillRect(1189, 457, 15, 70);
		};
		drawLevel();
		let data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
		for (let i = 0; i < data.length; i += 4) {
			pixels.push([data[i], data[i + 1], data[i + 2], data[i + 3] / 255]);
		};
		function getPixel(x, y) {
			return pixels[Math.floor(x + (y * canvas.width))];
		};
		function mouseMove(e) {
			mouseVelX = e.clientX - mouseX;
			mouseVelY = e.clientY - mouseY;
			mouseX = e.clientX;
			mouseY = e.clientY;
		};
		function drawCircle(x, y, r) {
			ctx.beginPath();
			ctx.arc(x, y, r, 0, Math.PI*2);
			ctx.fill();
		};
		function drawLine(p1, p2) {
			ctx.beginPath();
			ctx.moveTo(p1[0], p1[1]);
			ctx.lineTo(p2[0], p2[1]);
			ctx.stroke();
		};
		function distance(p1, p2) {
			return Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);
		};
		function lerp(min, max, mult) {
			return min * (1 - mult) + max * mult;
		};
		function generation(e) {
			if (e.key == " ") {
				cubes = cubes.sort((a, b) => distance([a.x, a.y], [mouseX, mouseY]) - distance([b.x, b.y], [mouseX, mouseY]));
				cubes.splice(1, cubes.length - 1);
				bestX = Math.max(bestX, cubes[0].x);
				cubes.forEach(cube => {
					cube.x = 100;
					cube.y = canvas.height / 2;
				});
				for (let i = 1; i < numberOfCubes; i++) {
					cubes.push(new Cube(structuredClone(cubes[Math.floor(Math.random() * 1)].brain)));
					NeuralNetwork.mutate(cubes[cubes.length - 1].brain, 0.1);
				};
				cubes.forEach(cube => cube.dead = false);
			};
		};
		function deg2rad(degrees) {
			return degrees * Math.PI / 180;
		};

		function loop() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawLevel();
			cubes.forEach((cube, i) => {
				if (!cube.dead) {
					let rayDistances = [];
					for (let rayDir = 0; rayDir < 360; rayDir += 360 / numberOfRays) {
						rayX = cube.x;
						rayY = cube.y;
						while (getPixel(Math.floor(rayX), Math.floor(rayY))[3] == 0) {
							rayX += Math.sin(deg2rad(rayDir)) * 5;
							rayY += Math.cos(deg2rad(rayDir)) * 5;
						};
						rayDistances.push(distance([cube.x, cube.y], [rayX, rayY]));
						ctx.lineWidth = 2;
						ctx.strokeStyle = "yellow";
						//ctx.beginPath();
						//ctx.moveTo(cube.x, cube.y);
						//ctx.lineTo(rayX, rayY);
						//ctx.stroke();
					};
					let inputs = rayDistances;
					let outputs = NeuralNetwork.feedForward(inputs, cube.brain); // left right down up
					let speed = 3;
					if (outputs[0] == 1) cube.x -= speed;
					if (outputs[1] == 1) cube.x += speed;
					if (outputs[2] == 1) cube.y -= speed;
					if (outputs[3] == 1) cube.y += speed;
					//cube.x = mouseX;
					//cube.y = mouseY;
					if (getPixel(Math.floor(cube.x), Math.floor(cube.y))[3] == 1) {
						cube.dead = true;
					};
				};
				ctx.fillStyle = cube.dead ? "rgba(255, 0, 0, 0.8)" : "rgba(0, 0, 0, 0.1)";
				ctx.fillRect(cube.x - 8, cube.y - 8, 16, 16);
			});
			ctx.fillStyle = "blue";
			ctx.fillText(`${mouseX}, ${mouseY}`, 16, 32);
			ctx.fillStyle = "green";
			ctx.fillRect(bestX - 1, 0, 2, canvas.height);

			requestAnimationFrame(loop);
		};
		loop();
	</script>
</html>
