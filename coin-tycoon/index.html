<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Thirsty Red Chair</title>
		<style>
			* {
				box-sizing: border-box;
			}
			html,body {
				width: 100%;
				height: 100%;
			}
			body {
				margin: 0;
				overflow: hidden;
			}
			#canvas,#canvas-wrapper {
				width: 100%;
				height: 100%;
				outline: none;
			}
		</style>
		<script type="x-shader/x-vertex" id="vertex-shader">
			precision mediump float;

			attribute vec2 a_position;
			attribute vec2 a_texcoord;

			uniform vec2 u_screen;
			uniform vec2 u_camera;

			varying vec2 v_texcoord;
			void main() {
				vec4 position = vec4((a_position - u_camera) / 5.0, 0.0, 1.0);
				position.x *= u_screen.y / u_screen.x;
				gl_Position = position;
				v_texcoord = a_texcoord / 32.0;
			}
		</script>
		<script type="x-shader/x-fragment" id="fragment-shader">
			precision mediump float;

			varying vec2 v_texcoord;

			uniform sampler2D u_atlas;

			void main() {
				vec4 color = texture2D(u_atlas, v_texcoord);
				if (color.a < 0.8) {
					discard;
				};
				gl_FragColor = color;
			}
		</script>
		<script src="perlin.js"></script>
	</head>
	<body>
		<div id="canvas-wrapper" tabindex="0">
			<canvas id="canvas"></canvas>
		</div>
		<script>
			const canvas = document.getElementById("canvas");
			canvas.width = innerWidth;
			canvas.height = innerHeight;
			const gl = canvas.getContext("webgl");

			var keys = {};
			const wrapper = document.getElementById("canvas-wrapper");
			wrapper.addEventListener("keydown", function(e){
				keys[e.key] = true;
			});
			wrapper.addEventListener("keyup", function(e){
				keys[e.key] = false;
			});
			function isDown(key) {
				return keys[key] ?? false;
			};

			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
			function createShader(gl, type, source) {
				var shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);
				var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
				if (success) {
					return shader;
				};
				console.log(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
			};
			function createProgram(gl, vertexShader, fragmentShader) {
				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				var success = gl.getProgramParameter(program, gl.LINK_STATUS);
				if (success) {
					return program;
				};
			
				console.log(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);
			};
			var vertexShaderCode = document.getElementById("vertex-shader").firstChild.nodeValue;
			var fragmentShaderCode = document.getElementById("fragment-shader").firstChild.nodeValue;
			var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderCode);
			var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderCode);
			var program = createProgram(gl, vertexShader, fragmentShader);

			var a_positionLoc = gl.getAttribLocation(program, "a_position");
			var a_texcoordLoc = gl.getAttribLocation(program, "a_texcoord");
			var u_screenLoc = gl.getUniformLocation(program, "u_screen");
			var u_cameraLoc = gl.getUniformLocation(program, "u_camera");

			var atlas = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, atlas);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
			var image = new Image();
			image.src = "data:image/png;base64,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AMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEAMIEALL+/PP/AeYFgHEzpV0ZAAAAAElFTkSuQmCC";
			image.addEventListener("load", function(){
				gl.bindTexture(gl.TEXTURE_2D, atlas);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
				gl.generateMipmap(gl.TEXTURE_2D);
			});
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			
			var level = {
				"blox": [],
				"blockHealth": [],
				"path": [],
				"enemies": [{"type": "mob", "x": 260, "y": 250}],
				"width": 500,
				"height": 500
			};
			var player = {
				"x": 250,
				"y": 250,
				"width": 0.5,
				"height": 0.5
			};
			var camera = {
				"x": 0,
				"y": 0
			};
			noise.seed(Math.random());
			for (let x = 0; x < 500; x++) {
				level.blox[x] = [];
				level.path[x] = [];
				for (let y = 0; y < 500; y++) {
					level.blox[x][y] = noise.perlin2(x / 4, y / 4 ) > 0 ? 1 : 0;
					level.path[x][y] = 0;
				};
			};
			function lerp(a, b, t) {
				return (b - a) * t + a;
			};
			function rotate(x, y, theta) {
				x1 = x * Math.cos(theta) - y * Math.sin(theta);
				y1 = y * Math.cos(theta) + x * Math.sin(theta);
				return {
					x: x1,
					y: y1
				};
			};
			function pathfind(x, y, steps) {
				for (let x = 0; x < level.width; x++)
				var thems = [{x: x, y: y}];
				var newthems = [];
				for (let i = 0; i < steps; i++) {
					newthems = [];
					for (let them of thems) {
						if (them.y + 1 < level.height && level.blox[them.x][them.y + 1] === 0 && level.path[them.x][them.y + 1] === 0) {
							newthems.push({x: them.x, y: them.y + 1});
							level.path[them.x][them.y + 1] = 2;
						};
						if (them.x + 1 < level.width && level.blox[them.x + 1][them.y] === 0 && level.path[them.x + 1][them.y] === 0) {
							newthems.push({x: them.x + 1, y: them.y});
							level.path[them.x + 1][them.y] = 3;
						};
						if (them.y - 1 > 0 && level.blox[them.x][them.y - 1] === 0 && level.path[them.x][them.y - 1] === 0) {
							newthems.push({x: them.x, y: them.y - 1});
							level.path[them.x][them.y - 1] = 4;
						};
						if (them.x - 1 > 0 && level.blox[them.x - 1][them.y] === 0 && level.path[them.x - 1][them.y] === 0) {
							newthems.push({x: them.x - 1, y: them.y});
							level.path[them.x - 1][them.y] = 1;
						};
					};
					thems = newthems;
				};
			};
			function die() {
				alert("YOU DIED");
				player.x = 32493;
			};
			var animFrames = 0;
			function render() {
				var positionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				var positions = [
				];
				addCube = (x, y, w, h, r, u, v, s, t) => {
					var origin = {x: x + w / 2, y: y + h / 2};
					var points = {
						x1: x,		y1: y,
						x2: x + w,	y2: y,
						x3: x,		y3: y + h,
						x4: x + w,	y4: y + h
					};
					var rotatedPointVectors = [
						rotate(points.x1 - origin.x, points.y1 - origin.y, -r),
						rotate(points.x2 - origin.x, points.y2 - origin.y, -r),
						rotate(points.x3 - origin.x, points.y3 - origin.y, -r),
						rotate(points.x4 - origin.x, points.y4 - origin.y, -r)
					];
					points.x1 = rotatedPointVectors[0].x + origin.x;
					points.y1 = rotatedPointVectors[0].y + origin.y;
					points.x2 = rotatedPointVectors[1].x + origin.x;
					points.y2 = rotatedPointVectors[1].y + origin.y;
					points.x3 = rotatedPointVectors[2].x + origin.x;
					points.y3 = rotatedPointVectors[2].y + origin.y;
					points.x4 = rotatedPointVectors[3].x + origin.x;
					points.y4 = rotatedPointVectors[3].y + origin.y;
					positions.push(
						points.x3,	points.y3, u, v,
						points.x1,	points.y1, u, v + t,
						points.x2,	points.y2, u + s, v + t,
						points.x3,	points.y3, u, v,
						points.x4,	points.y4, u + s, v,
						points.x2,	points.y2, u + s, v + t
					);
				};
				addCube(-10000, -10000, 20000, 20000, 0, 1, 0, 1, 1);
				for (let x = 0; x < level.blox.length; x++) {
					for (let y = 0; y < level.blox[x].length; y++) {
						if (x > camera.x - 10 && x < camera.x + 10 && y > camera.y - 10 && y < camera.y + 10) {
							if (level.blox[x][y] === 1) {
								addCube(x, y, 1, 1, 0, 0, 0, 1, 1);
							};
							if (level.path[x][y] !== 0) {
								addCube(x, y, 1, 1, (level.path[x][y] - 1) * Math.PI / 2, 3 + Math.floor(animFrames / 7 % 4), 2, 1, 1);
							};
						};
					};
				};
				for (let enemy of level.enemies) {
					addCube(enemy.x - 0.45, enemy.y - 0.45, 0.9, 0.9, Math.atan2(player.x - enemy.x, player.y - enemy.y) - Math.PI / 2, 1, 1, 1, 1);
				};
				addCube(player.x - player.width / 2, player.y - player.height / 2, player.width, player.height, 0, 0, 1, 1, 1);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
				
				var uvBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
				gl.enableVertexAttribArray(a_texcoordLoc);
				gl.vertexAttribPointer(a_texcoordLoc, 2, gl.FLOAT, false, 16, 2 * Float32Array.BYTES_PER_ELEMENT);

				gl.uniform2fv(u_screenLoc, [canvas.width, canvas.height]);
				gl.uniform2fv(u_cameraLoc, [camera.x, camera.y]);

				gl.clearColor(0, 0, 0, 1);
				gl.clear(gl.COLOR_BUFFER_BIT);
				gl.useProgram(program);

				gl.enableVertexAttribArray(a_positionLoc);
				gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
				gl.vertexAttribPointer(a_positionLoc, 2, gl.FLOAT, false, 16, 0);
				gl.drawArrays(gl.TRIANGLES, 0, positions.length / 4);
				animFrames++;
			};
			function tick() {
				var newPlayerX = player.x + (isDown("ArrowRight") - isDown("ArrowLeft")) * 0.1;
				var newPlayerY = player.y + (isDown("ArrowUp") - isDown("ArrowDown")) * 0.1;
				var xCollision = false;
				var yCollision = false;
				pathfind(player.x, player.y, 10);
				for (let enemy of level.enemies) {
					let x = Math.floor(enemy.x);
					let y = Math.floor(enemy.y);
					if (level.path[x][y] === 1) {
						enemy.x += 0.07;
					};
					if (level.path[x][y] === 2) {
						enemy.y -= 0.07;
					};
					if (level.path[x][y] === 3) {
						enemy.x -= 0.07;
					};
					if (level.path[x][y] === 4) {
						enemy.y += 0.07;
					};
				};
				for (let x = 0; x < level.blox.length; x++) {
					for (let y = 0; y < level.blox[x].length; y++) {
						if (level.blox[x][y] === 1 && newPlayerX + player.width / 2 > x && newPlayerX - player.width / 2 < x + 1 && player.y + player.height / 2 > y && player.y - player.height / 2 < y + 1) {
							xCollision = true;
						};
						if (level.blox[x][y] === 1 && player.x + player.width / 2 > x && player.x - player.width / 2 < x + 1 && newPlayerY + player.height / 2 > y && newPlayerY - player.height / 2 < y + 1) {
							yCollision = true;
						};
					};
				};
				if (!xCollision) {player.x = lerp(player.x, newPlayerX, yCollision ? 0.5 : 1)};
				if (!yCollision) {player.y = lerp(player.y, newPlayerY, xCollision ? 0.5 : 1)};
				camera.x = player.x;
				camera.y = player.y;
			};
			function loop() {
				tick();
				render();
				requestAnimationFrame(loop);
			};
			loop();
		</script>
	</body>
</html>
