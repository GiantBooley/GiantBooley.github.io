
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>forest simulator 3d</title>
		<style>
			* {
				box-sizing: border-box;
			}
			html,body {
				width: 100%;
				height: 100%;
			}
			body {
				margin: 0;
				overflow: hidden;
			}
			#canvas-wrapper,#game,#thing {
				width: 100%;
				height: 100%;
				outline: none;
			}
			#game {
				user-select: none;
			}
			#canvas {
				width: 100%;
				height: 100%;
			}
			#shop-button {
				position: absolute;
				top: 10px;
				right: 10px;
				color: black;
				background-color: white;
				border: 5px solid black;
				border-radius: 5px;
				padding: 10px;
				font-family: Arial, Helvetica, sans-serif;
				font-size: 20px;
			}
			#shop {
				display: none;
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				background-color: white;
				border-radius: 10px;
				border: 5px solid black;
				padding: 5px;
				width: 80%;
				height: calc(100% - 100px);
				overflow: auto;
			}
			#stats {
				margin: 0;
				position: absolute;
				left: 10px;
				top: 2px;
				font-family: Arial, sans-serif;
				color: yellow;
				font-size: 30px;
				text-shadow: 0px 0px 3px black;
			}
			h1,h2,h3,h4 {
				margin: 0;
			}
			#health {
				position: absolute;
				bottom: 0px;
				left: 0px;
				width: 600px;
				height: 50px;
				background-color: black;
			}
			#health-inner {
				width: 600px;
				height: 50px;
				background-color: rgb(0, 255, 0);
			}
			#joystick {
				position: absolute;
				display: flex;
				align-items: center;
				justify-content: center;
				bottom: 100px;
				right: 100px;
				width: 200px;
				height: 200px;
				background-color: gray;
				border-radius: 50%;
				opacity: 0.8;
				display: none;
			}
			#circle-thing {
				width: 50px;
				height: 50px;
				background-color: lightgray;
				border-radius: 50%;
				transform: translate(0px, 0px);
			}
			#shop-coins {
				width: 50%;
				float: left;
			}
			#shop-gems {
				width: 50%;
				float: right;
			}
			#notification {
				font-family: Arial, sans-serif;
				position: absolute;
				font-size: 30px;
				color: yellow;
				bottom: 10%;
				left: 0px;
				width: 100%;
				text-align: center;
				text-shadow: 0px 0px 3px black;
			}
			#obelisk-shop {
				display: none;
				position: absolute;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				background-color: white;
				border-radius: 10px;
				border: 5px solid black;
				padding: 5px;
				width: 80%;
				height: calc(100% - 100px);
				overflow: auto;
			}
			#obelisk-shop-button {
				position: absolute;
				top: 70px;
				right: 10px;
				color: black;
				background-color: white;
				border: 5px solid black;
				border-radius: 5px;
				padding: 10px;
				font-family: Arial, Helvetica, sans-serif;
				font-size: 20px;
			}
		</style>
	</head>
	<body>
		<div id="thing" tabindex="0" onkeydown="if (event.key == 'Escape') shopButton();">
			<div id="game" tabindex="0" onmouseup="joystick.mouseUp(event);" ontouchend="joystick.mouseUp(event);" onmousemove="joystick.mouseMove(event);" ontouchmove="joystick.mouseMove(event);" oncontextmenu="return false;">
				<div id="canvas-wrapper" tabindex="0" onkeydown="keyDownFunction(event);" onkeyup="keysDown[event.key] = false;">
					<canvas id="canvas"></canvas>
				</div>
				<div id="stats">score: -<br>coins: -</div>
				<button id="shop-button" onclick="shopButton();">SHOP</button>
				<button id="obelisk-shop-button" onclick="obeliskShopButton();">OBELISK</button>
				<div id="health">
					<div id="health-inner"></div>
				</div>
				<div id="joystick" onmousedown="joystick.mouseDown(event);" ontouchstart="joystick.mouseDown(event);"><div id="circle-thing"></div></div>
			</div>
			<div id="shop">
				<h1>shop</h1>
				<div id="saves">
					<select id="save-slot-selector">
						<option value="0" selected>slot 0</option>
						<option value="1">slot 1</option>
						<option value="2">slot 2</option>
					</select>
					<button onclick="saveSlot(document.getElementById('save-slot-selector').value);">save</button>
					<button onclick="loadSlot(document.getElementById('save-slot-selector').value);">load</button>
				</div>
				<hr>
				<input type="checkbox" id="joystick-checkbox"><label for="joystick-checkbox">joystick</label><br>
				<input type="checkbox" id="animations-checkbox"><label for="animations-checkbox">animations</label>
				<div id="shop-coins">
					<div id="boots">
						<h3>boots</h3>
						<button onclick="clickShoeButton(this, 'sketchers');">Sketchers (0 coins)</button><br>
						<button onclick="clickShoeButton(this, 'tennis rackets');">Tennis rackets (30 coins)</button><br>
						<button onclick="clickShoeButton(this, 'running shoes');">Running shoes (60 coins)</button><br>
						<button onclick="clickShoeButton(this, 'spring boots');">Spring boots (90 coins)</button><br>
						<button onclick="clickShoeButton(this, 'spike boots');">Spike boots (100 coins)</button><br>
						<button onclick="clickShoeButton(this, 'feather boots');">Feather boots (120 coins)</button><br>
						<button onclick="clickShoeButton(this, 'stepping boots');">Stepping boots (150 coins)</button><br>
						<button onclick="clickShoeButton(this, 'magnet boots');">Magnet boots (170 coins)</button><br>
					</div><br>
					<div id="food">
						<h3>food</h3><br>
						<label>government meal</label><label id="government-meal-howmany">(0)</label><button onclick="devourFood('government meal');">devour</button><button onclick="purchaseFood('government meal');">purchase (1 coin)</button><br>
						<br>
						<label>apple</label><label id="apple-howmany">(0)</label><button onclick="devourFood('apple');">devour</button><button onclick="purchaseFood('apple');">purchase (5 coins)</button><br>
						<label>bread</label><label id="bread-howmany">(0)</label><button onclick="devourFood('bread');">devour</button><button onclick="purchaseFood('bread');">purchase (10 coins)</button><br>
						<label>burger</label><label id="burger-howmany">(0)</label><button onclick="devourFood('burger');">devour</button><button onclick="purchaseFood('burger');">purchase (14 coins)</button><br>
						<label>cold meal</label><label id="cold-meal-howmany">(0)</label><button onclick="devourFood('cold meal');">devour</button><button onclick="purchaseFood('cold meal');">purchase (19 coins)</button><br>
						<label>meal</label><label id="meal-howmany">(0)</label><button onclick="devourFood('meal');">devour</button><button onclick="purchaseFood('meal');">purchase (23 coins)</button><br>
						<label>warm meal</label><label id="warm-meal-howmany">(0)</label><button onclick="devourFood('warm meal');">devour</button><button onclick="purchaseFood('warm meal');">purchase (27 coins)</button><br>
						<label>hot meal</label><label id="hot-meal-howmany">(0)</label><button onclick="devourFood('hot meal');">devour</button><button onclick="purchaseFood('hot meal');">purchase (31 coins)</button><br>
						<label>crispy gooey homemade mac and cheese</label><label id="crispy-gooey-homemade-mac-and-cheese-howmany">(0)</label><button onclick="devourFood('crispy gooey homemade mac and cheese');">devour</button><button onclick="purchaseFood('crispy gooey homemade mac and cheese');">purchase (34 coins)</button><br>
						<label>cow brain</label><label id="cow-brain-howmany">(0)</label><button onclick="devourFood('cow brain');">devour</button><button onclick="purchaseFood('cow brain');">purchase (38 coins)</button><br>
						<label>filling warm meal</label><label id="filling-warm-meal-howmany">(0)</label><button onclick="devourFood('filling warm meal');">devour</button><button onclick="purchaseFood('filling warm meal');">purchase (41 coins)</button><br>
						<br>
						<label>buckwheat pancake</label><label id="buckwheat-pancake-howmany">(0)</label><button onclick="devourFood('buckwheat pancake');">devour</button><button onclick="purchaseFood('buckwheat pancake');">purchase (44 coins)</button><br>
						<label>sopping meal</label><label id="sopping-meal-howmany">(0)</label><button onclick="devourFood('sopping meal');">devour</button><button onclick="purchaseFood('sopping meal');">purchase (47 coins)</button><br>
						<label>emptying cold meal</label><label id="emptying-cold-meal-howmany">(0)</label><button onclick="devourFood('emptying cold meal');">devour</button><button onclick="purchaseFood('emptying cold meal');">purchase (49 coins)</button><br>
						<label>piping hot meal</label><label id="piping-hot-meal-howmany">(0)</label><button onclick="devourFood('piping hot meal');">devour</button><button onclick="purchaseFood('piping hot meal');">purchase (52 coins)</button><br>
						<label>styrofoam tupperware baggy full of a reheated rehydrated piping hot filling sloppy sopping warm meal portion</label><label id="styrofoam-tupperware-baggy-full-of-a-reheated-rehydrated-piping-hot-filling-sloppy-sopping-warm-meal-portion-howmany">(0)</label><button onclick="devourFood('styrofoam tupperware baggy full of a reheated rehydrated piping hot filling sloppy sopping warm meal portion');">devour</button><button onclick="purchaseFood('styrofoam tupperware baggy full of a reheated rehydrated piping hot filling sloppy sopping warm meal portion');">purchase (54 coins)</button>
					</div><br>
					<div id="stuff">
						<h3>stuff</h3><br>
						<label>ladder</label><label id="ladder-howmany">(0)</label><button onclick="placeLadder();">place</button><button onclick="purchaseLadder();">purchase (10 coins)</button><br>
						<label>tall ladder</label><label id="tall-ladder-howmany">(0)</label><button onclick="placeTallLadder();">place</button><button onclick="purchaseTallLadder();">purchase (25 coins)</button>
					</div>
				</div>
				<div id="shop-gems">
					<div id="potions">
						<h3>alchemy (potions)</h3>
						<label>speed potion (10 seconds)</label><label id="speed-potion-howmany">(0)</label><button onclick="chugPotion('speed potion');">chug</button><button onclick="brewPotion('speed potion');">brew (2 gems)</button><br>
						<label>jumping potion (10 seconds)</label><label id="jumping-potion-howmany">(0)</label><button onclick="chugPotion('jumping potion');">chug</button><button onclick="brewPotion('jumping potion');">brew (3 gems)</button><br>
						<label>regeneration potion (10 seconds)</label><label id="regeneration-potion-howmany">(0)</label><button onclick="chugPotion('regeneration potion');">chug</button><button onclick="brewPotion('regeneration potion');">brew (5 gems)</button><br>
						<label>spider potion (10 seconds)</label><label id="spider-potion-howmany">(0)</label><button onclick="chugPotion('spider potion');">chug</button><button onclick="brewPotion('spider potion');">brew (7 gems)</button><br>
						<label>levitation potion (10 seconds)</label><label id="levitation-potion-howmany">(0)</label><button onclick="chugPotion('levitation potion');">chug</button><button onclick="brewPotion('levitation potion');">brew (8 gems)</button><br>
						<label>anti gravity potion (10 seconds)</label><label id="anti-gravity-potion-howmany">(0)</label><button onclick="chugPotion('anti gravity potion');">chug</button><button onclick="brewPotion('anti gravity potion');">brew (10 gems)</button><br>
						<label>bird potion (10 seconds)</label><label id="bird-potion-howmany">(0)</label><button onclick="chugPotion('bird potion');">chug</button><button onclick="brewPotion('bird potion');">brew (12 gems)</button>
					</div>
				</div>
			</div>
			<div id="obelisk-shop">
				<h1>obelisk</h1>
				<hr>
				<label>health</label><button onclick="obeliskShopUpgradeButton('health');">upgrade (1 totem)</button><br>
				<label>speed</label><button onclick="obeliskShopUpgradeButton('speed');">upgrade (1 totem)</button><br>
				<label>jump</label><button onclick="obeliskShopUpgradeButton('jump');">upgrade (1 totem)</button>
			</div>
			<div id="notification">

			</div>
		</div>
	</body>
	<script>
		const canvas = document.getElementById("canvas");
		canvas.width = innerWidth;
		canvas.height = innerHeight;
		const ctx = canvas.getContext("2d");
		document.getElementById("canvas-wrapper").focus();

		class Tree {
			constructor() {
				this
			};
		};

		var keysDown = [];
		function isDown(key) {
			return keysDown[key] ?? false;
		};
		class CanvasImage {
			constructor(color, src) {
				this.image = new Image();
				//this.image.crossOrigin = "anonymous";
				this.width = 500;
				this.height = 500;
				this.url = src;
				this.loaded = false;
				this.color = color;
				let canvasimagething = this;
				this.image.onload = function() {
					canvasimagething.loaded = true;
					canvasimagething.width = this.width;
					canvasimagething.height = this.height;
					imagesLoaded++;
				};
			};
			draw(sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
				if (this.image.src !== this.url) {
					this.image.src = this.url;
				};
				ctx.fillStyle = this.color ?? "rgb(255, 0, 255)";
				if (arguments.length == 2) {
					if (this.loaded) {
						ctx.drawImage(this.image, arguments[0], arguments[1]);
					} else {
						ctx.fillRect(arguments[0], arguments[1], blockSize, blockSize);
					};
				} else if (arguments.length == 4) {
					if (this.loaded) {
						ctx.drawImage(this.image, arguments[0], arguments[1], arguments[2], arguments[3]);
					} else {
						ctx.fillRect(arguments[0], arguments[1], arguments[2], arguments[3]);
					};
				} else if (arguments.length == 8) {
					if (this.loaded) {
						ctx.drawImage(this.image, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7]);
					} else {
						ctx.fillRect(arguments[4], arguments[5], arguments[6], arguments[7]);
					};
				} else {
					throw new TypeError("image draw 2 4 or 8 things");
				};
			};
		};
		class Joystick {
			constructor(element) {
				this.angle = 0;
				this.strength = 0;
				this.isMouseDown = false;
				this.element = element;
			};
			mouseMove(e) {
				if (!shop) {
					if (e.touches) {
						e = e.touches[0];
					};
					let coords = this.coordinates(e.clientX, e.clientY);
					let rect = this.element.getBoundingClientRect();
					let xy = this.coordinates(rect.x, rect.y);
					if (this.isMouseDown) {
						this.angle = Math.atan2(coords[0], coords[1]) * 180 / Math.PI;
						this.strength = clamp(Math.sqrt((coords[0] - (xy[0] + rect.width / 2)) ** 2 + (coords[1] - (xy[1] + rect.height / 2)) ** 2) / 100, 0, 1);
					};
					this.updateCircle();
				};
			};
			mouseUp(e) {
				if (!shop) {
					if (e.touches) {
						e = e.touches[0];
					};
					this.isMouseDown = false;
					this.angle = 0;
					this.strength = 0;
					this.updateCircle();
				};
			};
			mouseDown(e) {
				if (!shop) {
					if (e.touches) {
						e = e.touches[0];
					};
					this.isMouseDown = true;
					this.mouseMove(e);
				};
			};
			coordinates(x, y) {
				let rect = this.element.getBoundingClientRect();
				return [x - (rect.x + rect.width / 2), y - (rect.y + rect.height / 2)];
			};
			updateCircle() {
				document.getElementById("circle-thing").style.transform = "translate(" + (Math.sin(this.angle * Math.PI / 180) * this.strength * 100) + "px, " + (Math.cos(this.angle * Math.PI / 180) * this.strength * 100) + "px)";
			};
		};
		Math.mod = function(a, b) {
			return ((a % b) + b) % b;
		};
		Array.prototype.random = function() {
			return this[Math.floor(Math.random() * this.length)];
		};

		var blockSize = 50;
		var playerX = 1.5;
		var playerY = 0;
		var playerXV = 0;
		var playerYV = 0;
		var cameraX = playerX * blockSize - (canvas.width / 2);
		var cameraY = (playerY + 1) * -blockSize - (canvas.height / 2);
		var onGround = false;
		var seeds = [];
		var imagesLoaded = 0;
		var images = {
			guy: new CanvasImage("rgb(255, 255, 255)", "https://t4.ftcdn.net/jpg/01/73/40/15/360_F_173401516_HH7aV0os9LEum5ayYNrtoovV1jYrt561.jpg"),
			skyDay: new CanvasImage("rgb(200, 200, 255)", "https://media.hswstatic.com/eyJidWNrZXQiOiJjb250ZW50Lmhzd3N0YXRpYy5jb20iLCJrZXkiOiJnaWZcL3doeS1pcy1za3ktYmx1ZS5qcGciLCJlZGl0cyI6eyJyZXNpemUiOnsid2lkdGgiOjgyOH19fQ=="),
			grass: new CanvasImage("rgb(0, 200, 0)", "https://images.pexels.com/photos/413195/pexels-photo-413195.jpeg?cs=srgb&dl=pexels-pixmike-413195.jpg&fm=jpg"),
			hills: new CanvasImage("rgb(0, 150, 0)", "https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Chocolate_Hills_overview.JPG/1200px-Chocolate_Hills_overview.JPG"),
			ice: new CanvasImage("rgb(220, 220, 255)", "https://media.istockphoto.com/id/466513257/photo/image-of-light-blue-ice-design.jpg?s=612x612&w=0&k=20&c=tkgdD6LDAjjDL-J_OCc2tkN924FLtjvgSeQWgVBY5-Y="),
			snow: new CanvasImage("rgb(250, 250, 250)", "https://t4.ftcdn.net/jpg/00/73/39/95/360_F_73399559_6z3WIVyR5fPvXAW96ZFG1RBHsz6qVn4R.jpg"),
			dirt: new CanvasImage("rgb(128, 128, 0)", "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Dirt.JPG/640px-Dirt.JPG"),
			stones: new CanvasImage("rgb(200, 200, 200)", "https://d3mvlb3hz2g78.cloudfront.net/wp-content/uploads/2016/01/thumb_720_450_f_28.jpg"),
			stone: new CanvasImage("rgb(140, 140, 140)", "https://media.istockphoto.com/photos/light-grey-black-slate-stone-background-or-texture-picture-id1164746310?b=1&k=20&m=1164746310&s=612x612&w=0&h=nj0fWpCXBGNXhcUuWhXIF3HmcZiXMagkQ-DyPHAXLiw="),
			darkStone: new  CanvasImage("rgb(80, 80, 80)", "https://media.istockphoto.com/id/1136387527/photo/black-gray-grunge-background-dirty-concrete-wall-stucco-vintage-rock-texture-ombre-dark-stone.jpg?b=1&s=170667a&w=0&k=20&c=iUFh6s42MVX40KVd7bmkfcPHtMjYvqNsVndFQ2dMFWY="),
			stoneBackground: new CanvasImage("rgb(100, 100, 100)", "https://img.freepik.com/premium-photo/cave-wall-background_181627-531.jpg?w=2000"),
			packedSnow: new CanvasImage("rgb(120, 120, 150)", "https://thumbs.dreamstime.com/b/snow-surface-full-frame-background-texture-pattern-14970280.jpg"),
			magma: new CanvasImage("rgb(180, 70, 70)", "https://media.wired.co.uk/photos/606da0c989f3babb1f0133fb/master/w_1600%2Cc_limit/Lava.jpg"),
			lava: new CanvasImage("rgb(220, 0, 0)", "https://3docean.img.customer.envatousercontent.com/files/371574722/Image+Preview.jpg?auto=compress%2Cformat&fit=crop&crop=top&w=590&h=590&s=dc0fcc220b7f9d9b06eedf277f6f0844"),
			coin: new CanvasImage("rgb(255, 255, 0)", "https://m.media-amazon.com/images/I/51VLhMGtaTL._AC_SY1000_.jpg"),
			gem: new CanvasImage("rgb(150, 150, 255)", "https://cdn.britannica.com/78/170778-131-D35E060F/Reflections-diamond.jpg"),
			mysteryCrate: new CanvasImage("rgb(200, 200, 0)", "https://thumbs.dreamstime.com/b/crate-question-10722232.jpg"),
			ladder: new CanvasImage("rgb(200, 200, 160)", "https://m.media-amazon.com/images/I/71l4pWDxfTL.jpg"),
			guyJumping: new CanvasImage("rgb(255, 255, 255)", "https://thumbs.dreamstime.com/b/young-businessman-jumping-excitement-full-length-shot-isolated-white-background-156089211.jpg"),
			guyRunning: new CanvasImage("rgb(255, 255, 255)", "https://d2gg9evh47fn9z.cloudfront.net/800px_COLOURBOX3059374.jpg"),
			guyClimbingLadder: new CanvasImage("rgb(255, 255, 255)", "https://thumbs.dreamstime.com/b/businessman-climbing-ladder-8490148.jpg"),
			guyFalling: new CanvasImage("rgb(255, 255, 255)", "https://media.istockphoto.com/id/1297454782/photo/businessman-falling-down-isolated.jpg?s=612x612&w=0&k=20&c=UwgYtYVhktnHcYOHovzWOD3oZT1JNrguZcl5cQCKEGw="),
			guyDead: new CanvasImage("rgb(255, 200, 200)", "https://as1.ftcdn.net/v2/jpg/00/47/51/36/1000_F_47513651_NvfOZ1VY0YQwXriVuQKDCE6XLueitq57.jpg"),
			guyFlying: new CanvasImage("rgb(255, 255, 255)", "https://thumbs.dreamstime.com/b/flying-businessman-happy-high-isolated-white-37045715.jpg"),
			sentry: new CanvasImage("rgb(15, 15, 15)", "https://forums.rpgmakerweb.com/data/attachments/182/182633-4abbd801946b4603beb05c7c7c9e81a2.jpg"),
			sentryBarracks: new CanvasImage("rgb(170, 200, 170)", "https://images.fineartamerica.com/images/artworkimages/mediumlarge/2/abandoned-shack-in-woods-douglas-barnett.jpg"),
			pitfall: new CanvasImage("128, 128, 50", "https://content.instructables.com/FJL/5NV5/FV4LSDNT/FJL5NV5FV4LSDNT.jpg?auto=webp&fit=bounds&frame=1"),
			skyNight: new CanvasImage("rgb(0, 0, 0)", "https://images.unsplash.com/photo-1528818955841-a7f1425131b5?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8NHx8c3RhcnJ5JTIwc2t5fGVufDB8fDB8fA%3D%3D&w=1000&q=80"),
			moon: new CanvasImage("rgb(70, 170, 170)", "https://bigthink.com/wp-content/uploads/2020/10/origin-26.jpg"),
			ironNickelAlloy: new CanvasImage("rgb(210, 210, 210)", "https://cdn.openpr.com/R/b/Rb1218790_g.jpg"),
			mimic: new CanvasImage("rgb(240, 240, 240)", "https://www.halloweenforum.com/attachments/large-jpg.524714/"),
			error: new CanvasImage("rgb(255, 0, 255)", "https://proofthatblog.com/wp-content/uploads/2013/06/question-mark.jpg"),
			dybbuk: new CanvasImage("rgb(246, 223, 198)", "https://m.media-amazon.com/images/I/71lrPEdwT3L.jpg"),
			dybbukBox: new CanvasImage("rgb(212, 80, 56)", "https://travel.home.sndimg.com/content/dam/images/travel/fullrights/2016/03/29/0/TPOS101H_215929_761477.1304868.jpg.rend.hgtvcom.616.462.suffix/1491593805712.jpeg"),
			dybbukBoxOpen: new CanvasImage("rgb(202, 70, 46)", "https://i0.wp.com/bloody-disgusting.com/wp-content/uploads/2012/04/dybbuk-box.jpg"),
			golem: new CanvasImage("rgb(150, 150, 10)", "https://upload.wikimedia.org/wikipedia/commons/9/9f/Prague-golem-reproduction.jpg"),
			russetGolem: new CanvasImage("rgb(200, 150, 10)", "https://i.etsystatic.com/25674007/r/il/edaabf/2662111538/il_570xN.2662111538_kdmy.jpg"),
			totem: new CanvasImage("rgb(180, 180, 20)", "https://m.media-amazon.com/images/I/41yYu0ji5GL._AC_SX466_.jpg"),
			obelisk: new CanvasImage("rgb(30, 30, 120)", "https://cdnb.artstation.com/p/assets/images/images/029/560/119/large/julia-eriksson-rezle-juliaerikssonpillar.jpg?1597936831"),
			mars: new CanvasImage("rgb(190, 50, 50)", "https://assets.newatlas.com/dims4/default/a1ac999/2147483647/strip/true/crop/1920x1080+0+0/resize/1920x1080!/quality/90/?url=http%3A%2F%2Fnewatlas-brightspot.s3.amazonaws.com%2Farchive%2Fmars-rivers-2.jpg"),
			jupiter: new CanvasImage("rgb(200, 270, 20)", "https://thumbs.dreamstime.com/b/texture-surface-jupiter-elements-image-furnished-nasa-152406745.jpg"),
			saturn: new CanvasImage("rgb(200, 200, 150)", "https://www.solarsystemscope.com/textures/download/8k_saturn.jpg"),
			fourLeafClover: new CanvasImage("rgb(0, 210, 0)", "https://iadsb.tmgrup.com.tr/1b9d78/1200/627/0/133/1800/1074?u=https://idsb.tmgrup.com.tr/2019/06/30/superstitions-busted-four-leaf-clover-1561926823637.jpg"),
			leprechaun: new CanvasImage("rgb(100, 255, 100)", "https://upload.wikimedia.org/wikipedia/commons/0/0b/Leprechaun_ill_artlibre_jnl.png"),
			rainbow: new CanvasImage("rgb(100, 100, 100)", "https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Rainbow_Circle.svg/2040px-Rainbow_Circle.svg.png"),
			potOfGold: new CanvasImage("rgb(200, 200, 0)", "https://cdn5.vectorstock.com/i/1000x1000/74/44/green-full-pot-with-gold-coins-pot-with-four-leaf-vector-19727444.jpg"),
			aquaGolem: new CanvasImage("rgb(100, 100, 255)", "https://m.media-amazon.com/images/I/51o2o3s46sL._AC_UF894,1000_QL80_.jpg"),
			grimReaper: new CanvasImage("rgb(15, 15, 15)", "https://m.media-amazon.com/images/I/617-+DaGNBL._AC_SL1500_.jpg"),
			blood: new CanvasImage("rgb(255, 0, 0)", "https://cdn140.picsart.com/301576808315211.png"),
			burlapSack: new CanvasImage("rgb(160, 170, 20)", "https://m.media-amazon.com/images/I/510LO2c-5gL._AC_.jpg"),
			mechaGolem: new CanvasImage("rgb(210, 210, 210)", "https://www.guinnessworldrecords.com/Images/largest-humanoid-vehicle_tcm25-589034.jpg"),
			ruinedObelisk: new CanvasImage("rgb(50, 200, 50)", "https://c8.alamy.com/comp/EAXY7G/a-viking-rune-stone-is-seen-in-the-swedish-countryside-outside-of-EAXY7G.jpg"),
			saturn: new CanvasImage("rgb(90, 200, 50)", "https://www.solarsystemscope.com/textures/download/2k_saturn.jpg"),
			uranus: new CanvasImage("rgb(0, 255, 255)", "https://planet-texture-maps.fandom.com/wiki/Special:FilePath/Dh_uranus_texture.png"),
			neptune: new CanvasImage("rgb(0, 0, 255)", "https://www.solarsystemscope.com/textures/download/2k_neptune.jpg"),
			water: new CanvasImage("rgb(0, 0, 255)", "https://images.unsplash.com/photo-1476897017502-219c9169bd6f?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8M3x8d2F0ZXIlMjB0ZXh0dXJlfGVufDB8fDB8fA%3D%3D&w=1000&q=80")
		};
		var layers = {
			"-17": [images.ice, 0.03],
			"-16": [images.snow, 0.1],
			"-15": [images.stone, 0.35],
			"-14": [images.grass, 0.35],
			"-13": [images.dirt, 0.2],
			"-12": [images.stones, 0.25],
			"-11": [images.stone, 0.3],
			"-10": [images.darkStone, 0.35],
			"-9": [images.magma, 0.23],
			"-8": [images.lava, 0.1],
			"-7": [images.ironNickelAlloy, 0.14],
			"-6": [images.lava, 0.1],
			"-5": [images.magma, 0.23],
			"-4": [images.darkStone, 0.35],
			"-3": [images.stone, 0.3],
			"-2": [images.stones, 0.25],
			"-1": [images.dirt, 0.2],
			"0": [images.grass, 0.35],
			"1": [images.stone, 0.35],
			"2": [images.snow, 0.1],
			"3": [images.ice, 0.03],
			"4": [images.moon, 0.3],
			"5": [images.mars, 0.25],
			"6": [images.jupiter, 0.07],
			"7": [images.saturn, 0.07],
			"8": [images.uranus, 0.07],
			"9": [images.neptune, 0.07]
		};
		var level = {
			rows: [],
			originalRows: [],
			features: [],
			octaves: [],
			mobs: [],
			featureEntities: [],
			terrainFeatures: [],
			waterLevel: [],
			golems: []
		};
		var coins = 0;
		var gems = 0;
		var totems = 0;
		var fac = 
			"Marina silva is a brazilian politician and an activist for deforestation and other things. She was a rubber tapper and found that land was being invaded by rubber tappers and she started protecting thousands of hectares of land."
		;
		var facasd = false;
		var shop = false;
		var bootses = {
			"sketchers": {bought: true, cost: 0},
			"tennis rackets": {bought: false, cost: 30},
			"running shoes": {bought: false, cost: 60},
			"spring boots": {bought: false, cost: 90},
			"spike boots": {bought: false, cost: 100},
			"feather boots": {bought: false, cost: 120},
			"stepping boots": {bought: false, cost: 150},
			"magnet boots": {bought: false, cost: 170}
		};
		var foods = {
			"government meal": {cost: 1, hunger: 0.03, howmany: 0},
			"apple": {cost: 5, hunger: 0.1, howmany: 0},
			"bread": {cost: 10, hunger: 0.2, howmany: 0},
			"burger": {cost: 14, hunger: 0.3, howmany: 0},
			"cold meal": {cost: 19, hunger: 0.4, howmany: 0},
			"meal": {cost: 23, hunger: 0.5, howmany: 0},
			"warm meal": {cost: 27, hunger: 0.6, howmany: 0},
			"hot meal": {cost: 31, hunger: 0.7, howmany: 0},
			"crispy gooey homemade mac and cheese": {cost: 34, hunger: 0.8, howmany: 0},
			"cow brain": {cost: 38, hunger: 0.9, howmany: 0},
			"filling warm meal": {cost: 41, hunger: 1, howmany: 0},

			"buckwheat pancake": {cost: 44, hunger: 1.1, howmany: 0},
			"sopping meal": {cost: 47, hunger: 1.2, howmany: 0},
			"emptying cold meal": {cost: 49, hunger: -0.65, howmany: 0},
			"piping hot meal": {cost: 52, hunger: 1.4, howmany: 0},
			"styrofoam tupperware baggy full of a reheated rehydrated piping hot filling sloppy sopping warm meal portion": {cost: 54, hunger: 1.5, howmany: 0}
		};
		var potions = {
			"speed potion": {cost: 2, time: 0, duration: 10, howmany: 0},
			"jumping potion": {cost: 3, time: 0, duration: 10, howmany: 0},
			"regeneration potion": {cost: 5, time: 0, duration: 10, howmany: 0},
			"spider potion": {cost: 7, time: 0, duration: 10, howmany: 0},
			"levitation potion": {cost: 8, time: 0, duration: 10, howmany: 0},
			"anti gravity potion": {cost: 10, time: 0, duration: 10, howmany: 0},
			"bird potion": {cost: 12, time: 0, duration: 10, howmany: 0}
		};
		var boots = "sketchers";
		var health = 1;
		var dead = false;
		var ladders = 0;
		var inLadder = false;
		var joystick = new Joystick(document.getElementById("joystick"));
		var controls = {
			up: false,
			down: false,
			left: false,
			right: false
		};
		var tallLadders = 0;
		var score = 0;
		var frameCount = 0;
		var fps = 0;
		var fpsUpdateTime = 0;
		var flying = false;
		var pb = 0;
		var notification = "";
		var notificationTime = 0;
		var gameTime = 0;
		var developerMode = true;
		var macro = [];
		var macroTime = 0;
		var macroPlaying = false;
		var dybbukTime = 0;
		var crouching = false;
		var obeliskShop = false;
		var basePlayerSpeed = 0.2;
		var baseJumpHeight = 0.24;
		var maxHealth = 1;
		var resizeGroundUV = true;
		var inWater = false;
		var golems = {
			"golem": {
				height: 3,
				riseSpeed: 0.01,
				sinkSpeed: -0.01,
				image: images.golem
			},
			"russet golem": {
				height: 3,
				riseSpeed: 0.008,
				sinkSpeed: -0.01,
				image: images.russetGolem
			},
			"aqua golem": {
				height: 3,
				riseSpeed: 0.005,
				sinkSpeed: -0.005,
				image: images.aquaGolem
			},
			"mecha golem": {
				height: 3,
				riseSpeed: 0.01,
				sinkSpeed: -0.01,
				image: images.mechaGolem
			}
		};

		for (let i = 0; i < 10; i++) {
			level.octaves.push(perlinNoise1D());
		};
		function generateLevel() {
			let oldLength = level.rows.length;//rows.length == 0 ? -1 : rows.length;
			for (let i = oldLength; i < oldLength + 1000; i++) {
				let perlinHeight = 0;
				for (let j = 0; j < level.octaves.length; j++) {
					perlinHeight += ((perlinGetVal(level.octaves[j], i / (10 / (2 ** j))) - 0.5) * 4) / (2 ** j);
				};
				level.rows[i] = level.originalRows[i] = (level.rows[i - 1] ?? 0) + perlinHeight;
				level.featureEntities[i] = null;
				level.golems[i] = null;
			};

			// round stuff and coins n gems
			for (let i = oldLength; i < oldLength + 1000; i++) {// 0-air 1-coin 2-gem 3-ladder 4-tallladder 5-wall 6-mysterycrate 7-sentrybarracks 8-sentrybarracksnosentry 9-pitfall 10-dybbukbox 11-dybbukboxopen 12-totem 13-fourleafclover 14-potofgold 15-burlapsack 16-ruinedobelisk
				level.rows[i] = level.originalRows[i] = Math.round(level.rows[i]);
				level.waterLevel[i] = Math.max(-5 - level.rows[i], 0);
				let pool = [];
				if (Math.random() < 1 / 20) pool.push(1);
				if (Math.random() < 1 / 200) pool.push(2);
				if (Math.random() < 1 / 5000) pool.push(5);
				if (Math.random() < 1 / 1000) pool.push(6);
				if (Math.random() < 1 / 4000) pool.push(7);
				if (Math.random() < 1 / 2000) pool.push(10);
				if (Math.random() < 1 / 8000) pool.push(12);
				if (Math.random() < 1 / 8000) pool.push(13);
				if (Math.random() < 1 / 1500) pool.push(15);
				if (Math.random() < 1 / 20000) pool.push(16);
				if (Math.random() < 1 / 70 && new Set([level.rows[i - 2], level.rows[i - 1], level.rows[i], Math.round(level.rows[i + 1]), Math.round(level.rows[i + 2])]).size == 1) pool.push(9);
				level.features[i] = pool.length == 0 ? 0 : pool[Math.floor(Math.random() * pool.length)];

				if (Math.random() < 1 / 3000) {
					placeFeatureEntity("golem", i, false);
				};
				if (Math.random() < 1 / 8000) {
					placeFeatureEntity("russet golem", i, false);
				};
				if (Math.random() < 1 / 10000) {
					placeFeatureEntity("aqua golem", i, false);
				};
				if (Math.random() < 1 / 15000) {
					placeFeatureEntity("mecha golem", i, false);
				};

				if (Math.random() < 1 / 5000) {
					spawnMob("mimic", i + 0.5 + (Math.random() - 0.5) * 1.5, level.rows[i] + (Math.random() - 0.5) * 1.5);
				};
				if (Math.random() < 1 / 4212133121320.00) {
					level.terrainFeatures[i] = "rainbow";
				};
			};
		};
		generateLevel();
		playerY = level.rows[1];
		function getHittableRows(x) {
			hittableRows = [];
			if (Math.mod(x, 1) < 0.5) {
				hittableRows.push(Math.floor(x) - 1);
			};
			hittableRows.push(Math.floor(x));
			if (Math.mod(x, 1) > 0.5) {
				hittableRows.push(Math.floor(x) + 1);
			};
			return hittableRows;
		};
		function getLayer(y) {
			return Math.floor(y / 100);
		};
		function clamp(number, min, max) {
			return Math.min(Math.max(number, min), max);
		};
		function lerp(a, b, c) {
			return a * (1 - c) + b * c;
		};
		function inverseLerp(a, b, c) {
			return c / (b - a) + a;
		};

		function perlinNoise1D() {
			let MAX_VERTICES = 1024;
			let r = [];
			for (let i = 0; i < MAX_VERTICES; ++i) {
				r.push(Math.random()); // mulberry32(i + 100));
			};
			return {MAX_VERTICES, r};
		};
		function perlinGetVal(generator, x) {
			let t = x - Math.floor(x);
			let tRemapSmoothstep = t ** 2 * (3 - 2 * t);
			let xMin = Math.floor(x) & (generator.MAX_VERTICES - 1);
			let xMax = (xMin + 1) & (generator.MAX_VERTICES - 1);
			return lerp(generator.r[xMin], generator.r[xMax], tRemapSmoothstep);
		};
		function mulberry32(a) {
			let t = a += 0x6D2B79F5;
			t = Math.imul(t ^ t >>> 15, t | 1);
			t ^= t + Math.imul(t ^ t >>> 7, t | 61);
			return ((t ^ t >>> 14) >>> 0) / 4294967296;
		};
		function shopButton() {
			if (shop = !shop) {
				document.getElementById("shop").style.display = "block";
			} else {
				document.getElementById("shop").style.display = "none";
				document.getElementById("canvas-wrapper").focus();
			};
		};
		function obeliskShopButton() {
			if (obeliskShop = !obeliskShop) {
				document.getElementById("obelisk-shop").style.display = "block";
			} else {
				document.getElementById("obelisk-shop").style.display = "none";
				document.getElementById("canvas-wrapper").focus();
			};
		};
		function clickShoeButton(button, bootsreal) {
			if (bootses[bootsreal].bought) {
				boots = bootsreal;
			} else {
				if (coins >= bootses[bootsreal].cost) {
					bootses[bootsreal].bought = true;
					coins -= bootses[bootsreal].cost;
				} else {
					alert("bankrupt");
				};
			};
		};
		function purchaseFood(food) {
			if (coins >= foods[food].cost) {
				foods[food].howmany++;
				coins -= foods[food].cost;
			} else {
				alert("bankrupt");
			};
		};
		function devourFood(food) {
			if (foods[food].howmany >= 1) {
				foods[food].howmany--;
				health += foods[food].hunger;
				health = clamp(health, 0, maxHealth);
			};
		};
		function keyDownFunction(e) {
			if (e.repeat) return;
			keysDown[e.key] = true;
			if (e.key == "t") {
				facasd = true;
				setTimeout(() => {
					facasd = false;
				}, 3000);
			} else if (e.key === "l" && developerMode) {
				level.rows = JSON.parse(prompt("what level rows"));
			} else if (e.key === "r" && developerMode) {
				playerXV = 0;
				playerYV = 0;
				playerX = 1.5;
				playerY = level.rows[1] ?? 0;
				gameTime = 0;
			} else if (e.key === "m" && developerMode) {
				macro = prompt("what macro").split(",");
				macroTime = 0;
				macroPlaying = true;
			} else if (e.key === "p" && developerMode) {
				spawnMob(prompt("what mob"), playerX - 3, level.rows[Math.floor(playerX - 3)] ?? 0);
			} else if (e.key === "e") {
				let ruinedObeliskRows = getHittableRows(playerX).filter(it => level.features[it] === 16);
				if (ruinedObeliskRows.length > 0) {
					if (totems >= 1) {
						totems--;
						level.features[ruinedObeliskRows[0]] = 0;
						placeFeatureEntity("obelisk", ruinedObeliskRows[0], false);
					} else {
						alert("bankrupt");
					};
				};
			};
		};
		function purchaseLadder() {
			if (coins >= 10) {
				coins -= 10;
				ladders++;
			} else {
				alert("bankrupt");
			};
		};
		function placeLadder() {
			if (ladders >= 1 && level.features[Math.floor(playerX)] == 0) {
				level.features[Math.floor(playerX)] = 3;
				ladders--;
			};
		};
		function purchaseTallLadder() {
			if (coins >= 25) {
				coins -= 25;
				tallLadders++;
			} else {
				alert("bankrupt");
			};
		};
		function placeTallLadder() {
			if (tallLadders >= 1 && level.features[Math.floor(playerX)] == 0) {
				level.features[Math.floor(playerX)] = 4;
				tallLadders--;
			};
		};
		function brewPotion(potion) {
			if (gems >= potions[potion].cost) {
				potions[potion].howmany++;
				gems -= potions[potion].cost;
			} else {
				alert("bankrupt");
			};
		};
		function chugPotion(potion) {
			if (potions[potion].howmany >= 1) {
				potions[potion].howmany--;
				potions[potion].time += potions[potion].duration;
			};
		};
		function saveSlot(slot) {
			try{
			let saveCode = JSON.stringify({
				level,
				playerX,
				playerY,
				playerXV,
				playerYV,
				coins,
				gems,
				ladders,
				tallLadders,
				health,
				dead,
				bootses,
				boots,
				foods,
				potions,
				pb,
				gameTime,
				totems,
				dybbukTime,
				basePlayerSpeed,
				baseJumpHeight,
				maxHealth
			});
			localStorage.setItem("forestSimulator3DSaveSlot" + slot, saveCode);
		} catch(e) {alert(e.stack)}
		};
		function loadSlot(slot) {
			let saveCode = localStorage.getItem("forestSimulator3DSaveSlot" + slot);
			if (saveCode === null) {
				alert("save slot " + slot + " empty, to create a new save slot reload and press save in the new one you want to create")
			} else {
				saveCode = JSON.parse(saveCode);
				level = saveCode.level ?? level;
				playerX = saveCode.playerX ?? playerX;
				playerY = saveCode.playerY ?? playerY;
				playerXV = saveCode.playerYV ?? playerXV;
				coins = saveCode.coins ?? coins;
				gems = saveCode.gems ?? gems;
				ladders = saveCode.ladders ?? ladders;
				tallLadders = saveCode.tallLadders ?? tallLadders;
				health = saveCode.health ?? health;
				dead = saveCode.dead ?? dead;
				bootses = saveCode.bootses ?? bootses;
				boots = saveCode.boots ?? boots;
				foods = saveCode.foods ?? foods;
				potions = saveCode.potions ?? potions;
				pb = saveCode.pb ?? pb;
				gameTime = saveCode.gameTime ?? gameTime;
				totems = saveCode.totems ?? totems;
				dybbukTime = saveCode.dybbukTime ?? dybbukTime;
				basePlayerSpeed = saveCode.basePlayerSpeed ?? basePlayerSpeed;
				baseJumpHeight = saveCode.baseJumpHeight ?? baseJumpHeight;
				maxHealth = saveCode.maxHealth ?? maxHealth;
			};
		};
		function clearSlot(slot) {
			localStorage.removeItem("forestSimulator3DSaveSlot" + slot);
		};
		function clearAllSlots() {
			localStorage.clear();
		};
		function spawnMob(type, x, y) {
			let mob = {
				type: type,
				x: x,
				y: y,
				age: 0
			};
			if (type === "mimic") {
				mob.mimicTarget = ["coin", "gem"].random();
				mob.mimicTimer = false;
				mob.mimicking = true;
				mob.mimicSpawnAge = 0;
			};
			level.mobs.push(mob);
		};
		function notificate(message) {
			notification = message;
			notificationTime = 180;
		};
		function placeFeatureEntity(type, x) {
			let featureEntity = {
				"type": type
			};
			if (type === "obelisk") {
				featureEntity.yOffset = arguments[2] ? -4 : 0;
				featureEntity.riseSpeed = arguments[2] ? 0.005 : 0;
			};
			level.featureEntities[Math.floor(x)] = featureEntity;
		};
		function placeGolem(type, x, rising) {
			let golem = {
				"type": type,
				"yOffset": rising ? -golems[type].height : 0,
				"ySpeed": rising ? golems[type].riseSpeed : 0
			};
			level.golems[Math.floor(x)] = golem;
		};
		function obeliskShopUpgradeButton(item) {
			if (totems >= 1) {
				switch (item) {
					case "health":
						if (maxHealth < 2) {
							maxHealth = Math.min(maxHealth + 0.1, 2);
						} else {
							alert("upgrade maxed");
						};
						break;
					case "speed":
						if (basePlayerSpeed < 0.35) {
							basePlayerSpeed = Math.min(basePlayerSpeed + 0.02, 0.35);
						} else {
							alert("upgrade maxed");
						};
						break;
					case "jump":
						if (baseJumpHeight < 0.5) {
							baseJumpHeight = Math.min(baseJumpHeight + 0.03, 0.5);
						} else {
							alert("upgrade maxed");
						};
						break;
				};
				totems--;
			} else {
				alert("bankrupt");
			};
		};
		function tick() {
			document.getElementById("joystick").style.display = document.getElementById("joystick-checkbox").checked ? "flex" : "none";
			controls.up = 0 || isDown("ArrowUp") || isDown("w") || (joystick.strength > 0.5 && (joystick.angle > 112.5 || joystick.angle < -112.5)) || (macroPlaying && parseInt(macro[macroTime][0]));
			controls.down = isDown("ArrowDown") || isDown("s") || (joystick.strength > 0.5 && (joystick.angle > -67.5 && joystick.angle < 67.5)) || (macroPlaying && parseInt(macro[macroTime][1]));
			controls.left = isDown("ArrowLeft") || isDown("a") || (joystick.strength > 0.5 && (joystick.angle > -157.5 && joystick.angle < -22.5)) || (macroPlaying && parseInt(macro[macroTime][2]));
			controls.right = 0 || isDown("ArrowRight") || isDown("d") || (joystick.strength > 0.5 && (joystick.angle > 22.5 && joystick.angle < 157.5)) || (macroPlaying && parseInt(macro[macroTime][3]));
			if (macroPlaying) {
				macroTime++;
			};
			if (macroTime >= macro.length) {
				macroPlaying = false;
				macroTime = 0;
			};
			if (!shop && !dead && !obeliskShop) {
				if ((cameraX + canvas.width) / blockSize >= level.rows.length) { // playerx >=
					generateLevel();
				};

				let bakedRows = [...level.rows];
				for (let i = 0; i < bakedRows.length; i++) {
					bakedRows[i] += (level.features[i] === 5) * 5;
					if (level.golems[i] && level.golems[i].type === "golem") {
						let height = level.golems[i].yOffset + 3;
						bakedRows[i] = level.rows[i] + height;
					} else if (level.golems[i] && level.golems[i].type === "russet golem") {
						let height = level.golems[i].yOffset + 6;
						bakedRows[i] = level.rows[i]+ height;
					} else if (level.golems[i] && level.golems[i].type === "aqua golem") {
						let height = level.golems[i].yOffset + 9;
						bakedRows[i] = level.rows[i] + height;
					} else if (level.golems[i] && level.golems[i].type === "mecha golem") {
						let height = level.golems[i].yOffset + 12;
						bakedRows[i - 1] = level.rows[i] + height;
						bakedRows[i] = level.rows[i] + height;
						bakedRows[i + 1] = level.rows[i] + height;
					};
				};

				gameTime += 1 / 60;

				for (let potion in potions) {
					potions[potion].time = Math.max(potions[potion].time - (1 / 60), 0);
				};
				flying = potions["bird potion"].time > 0;
				inWater = playerY < level.rows[Math.floor(playerX)] + level.waterLevel[Math.floor(playerX)];

				// X MOVEMENT //
				
				let playerSpeed = basePlayerSpeed + (boots === "running shoes") * 0.04 + (potions["speed potion"].time > 0) * 0.1;
				let groundFriction = (boots === "spike boots") ? 0.9 : layers[clamp(getLayer(playerY), Math.min(...Object.keys(layers)), Math.max(...Object.keys(layers)))][1];
				if (controls.right != controls.left) {
					//move
					let sign = controls.right - controls.left;
					let maxXV = (inLadder ? sign * (boots == "magnet boots" ? 0 : 0.1) : (flying ? sign * 0.3 : (sign * playerSpeed)));
					playerXV = lerp(maxXV, playerXV, onGround ?  1 - groundFriction : 0.3) + (sign * 0.04 * (controls.up && onGround && !inWater));
				} else {
					//friction
					playerXV *= inLadder ? 0 : (onGround ? 1 - groundFriction : 0.99);
				};

				if (inWater) {
					playerXV *= 0.9;
					playerXV = clamp(playerXV, -0.3, 0.3);
				};
				let hittableRows = getHittableRows(playerX + playerXV);
				if ((hittableRows[0] != undefined && bakedRows[hittableRows[0]] > playerY) || (hittableRows[1] != undefined && bakedRows[hittableRows[1]] > playerY)) {
					let max = hittableRows.reduce((a, b) => bakedRows[a] > bakedRows[b] ? a : b);
					if (onGround && playerY >= bakedRows[max] - (boots == "stepping boots" ? 1 : 0.5) && potions["spider potion"].time <= 0) {
						playerY = bakedRows[max];
					} else {
						playerXV = Math.ceil(playerX + (playerXV / 2)) - 0.5 - playerX;
						if (potions["spider potion"].time > 0) {
							playerYV = 0;
							playerY += 0.2;
						};
					};
				};
				playerX += playerXV;
				
				// Y MOVEMENT //

				if (inLadder) {
					playerYV = (controls.up - controls.down) * (boots == "magnet boots" ? 0 : 0.1);
				} else if (flying) {
					if (controls.up != controls.down) {
						playerYV = (controls.up - controls.down) * 0.3;
					};
					playerYV *= 0.99;
				} else {
					let jumpHeight = baseJumpHeight + (boots == "spring boots") * 0.06 + (potions["jumping potion"].time > 0) * 0.08;
					playerYV += controls.up * onGround * !inWater * (jumpHeight + Math.abs(playerXV) * 0.15);
				};

				//gravity
				let layer = clamp(getLayer(playerY), Math.min(...Object.keys(layers)), Math.max(...Object.keys(layers)));
				let gravity = 0;
				switch (layer) {
					case -7:
						if (boots === "magnet boots") {
							gravity = -0.024;
						} else {
							gravity = -0.012;
						};
						break;
					case 4:
						gravity = -0.007;
						break;
					case 5:
						gravity = -0.009;
						break;
					case 6:
						gravity = -0.015;
						break; 
					default:
						gravity = -0.012;
				};
				if (inWater) {
					if (controls.up === controls.down) {
						gravity = -0.001;
					} else {
						if (controls.up) {
							gravity = 0.01;
						} else if (controls.down) {
							gravity = -0.01;
						};
					};
				};
				playerYV = potions["levitation potion"].time > 0 ? 0.1 : (playerYV + ((inLadder || flying) ? 0 : gravity * ((potions["anti gravity potion"].time > 0) ? 0.5 : 1)));

				if (boots === "feather boots") {
					playerYV = Math.max(playerYV, -0.3);
				};
				if (inWater) {
					playerYV *= 0.98;
					playerYV = clamp(playerYV, -0.3, 0.3);
				};
				hittableRows = getHittableRows(playerX);
				let max = hittableRows.reduce((a, b) => bakedRows[a] > bakedRows[b] ? a : b);
				let oldOnGround = onGround;
				onGround = playerY + playerYV <= bakedRows[max];
				if (!oldOnGround && onGround && playerYV <= -0.6) {
					health -= playerYV * -0.05;
				};
				if (onGround) {
					if (getLayer(level.rows[max]) == 2 && level.rows[max] - 200 > (level.originalRows[max] - 200) * 0.9 && boots != "tennis rackets") {
						level.rows[max] -= 0.005;
						if (level.rows[max] - 200 < (level.originalRows[max] - 200) * 0.9) {
							level.rows[max] = (level.originalRows[max] - 200) * 0.9 + 200;
						};
					};
					playerY = bakedRows[max];
					playerYV = 0;
				};
				playerY += playerYV;

				// ROW LOOP //

				let oldInLadder = inLadder;
				inLadder = false;
				dybbukTime = Math.max(0, dybbukTime - 1);
				document.getElementById("obelisk-shop-button").style.display = "none";
				for (let i = 0; i < level.rows.length; i++) {
					// features
					if (playerX + 0.5 > i && playerX - 0.5 < i + 1) {
						if (playerY < level.rows[i] + 1) {
							switch (level.features[i]) {
								case 2:
									if (dybbukTime <= 0) {
										gems++;
									};
									level.features[i] = 0;
									break;
								case 6:
									if (dybbukTime <= 0) {
										let crateOption = ["food", "potion", "ladder", "coins", "gems", "nothing"].random();
										let specific = null;
										switch (crateOption) {
											case "food":
												specific = Object.keys(foods).random();
												foods[specific].howmany++;
												break;
											case "potion":
												specific = Object.keys(potions).random();
												potions[specific].howmany++;
												break;
											case "ladder":
												specific = ["ladder", "tall ladder"].random();
												switch (specific) {
													case "ladder":
														ladders++;
														break;
													case "tall ladder":
														tallLadders++;
												};
												break;
											case "coins":
												specific = Math.floor(Math.random() * 19 + 1);
												coins += specific;
												break;
											case "gems":
												specific = Math.floor(Math.random() * 3 + 1);
												gems += specific;
												break;
											case "nothing":
												if (Math.random() < 1/100) {
													specific = "spawned 1000 sentries";
													for (let i = 0; i < 1000; i++) {
														spawnMob("sentry", Math.random() * level.rows.length, 0);
													};
												} else {
													specific = "get better";
												};
										};
										notificate("mystery crate opened! item: " + crateOption + " (" + specific + ")");
									};
									level.features[i] = 0;
									break;
								case 10:
									dybbukTime = 1200;
									level.features[i] = 11;
									break;
								case 12:
									if (dybbukTime <= 0) {
										totems++;
									};
									level.features[i] = 0;
									break;
								case 13:
									spawnMob("leprechaun", i + 2.5, bakedRows[i]);
									level.features[i] = 0;
									break;
								case 14:
									let coinAmount = Math.round(Math.random() * 50 + 50);
									coins += coinAmount;
									notificate("pot of gold contains " + coinAmount + " coins");
									level.features[i] = 0;
									break;
								case 15:
									if (dybbukTime <= 0) {
										let food = Object.keys(foods).random();
										foods[food].howmany++;
										notificate("burlap sack contains " + food);
									};
									level.features[i] = 0;
									break;
							};
						};
						if (level.features[i] == 1 && (boots == "magnet boots" || playerY < level.rows[i] + 1)) {
							if (dybbukTime <= 0) {
								coins++;
							};
							level.features[i] = 0;
						};
						if ((playerY < level.rows[i] + 4 && level.features[i] == 3) || (playerY < bakedRows[i] + 6 && level.features[i] === 4)) {
							inLadder = true;
						};
						if (inLadder != oldInLadder) {
							playerXV = 0;
							playerYV = 0;
						};
						if (playerY < level.rows[i] + 3 && level.features[i] === 7) {
							if (dybbukTime <= 0) {
								spawnMob("sentry", i + 0.5, bakedRows[i + 1]);
							};
							level.features[i] = 8;
						};
						if (onGround && playerY == level.rows[i] && boots !== "tennis rackets" && level.features[i] == 9) {
							level.rows[i - 1] = level.rows[i] = level.rows[i + 1] = level.rows[i] - 4;
							level.features[i - 1] = 0;
							level.features[i] = 0;
							level.features[i + 1] = 0;
						};
						if (playerY < level.rows[i] + 4 && level.features[i] === 16) {
							notificate("press e to repair obelisk (1 totem)");
						};
					};
					// feature entities
					if (level.featureEntities[i]) {
						switch (level.featureEntities[i].type) {
							case "obelisk":
								level.featureEntities[i].yOffset += level.featureEntities[i].riseSpeed;
								if (level.featureEntities[i].yOffset > 0) {
									level.featureEntities[i].riseSpeed = 0;
									level.featureEntities[i].yOffset = 0;
								} else if (level.featureEntities[i].yOffset <= -4) {
									level.featureEntities[i] = null;
									continue;
								};
								if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY < level.rows[i] + 4 && level.featureEntities[i].riseSpeed === 0) {
									document.getElementById("obelisk-shop-button").style.display = "block";
								};
								break;
						};
					};
					if (level.golems[i]) {
						let spawnOffset;
						let golemType = level.golems[i].type;
						/*switch (level.golems[i].type) {
							case "golem":*/
								spawnOffset = 35;
								if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY <= level.rows[i] + golems[golemType].height && onGround && level.golems[i].ySpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
									level.golems[i].ySpeed = golems[golemType].sinkSpeed;
									placeGolem("golem", i + spawnOffset, true);
								};
								level.golems[i].yOffset += level.golems[i].ySpeed;
								if (level.golems[i].yOffset > 0) {
									level.golems[i].ySpeed = 0;
									level.golems[i].yOffset = 0;
								} else if (level.golems[i].yOffset <= -golems[golemType].height) {
									level.golems[i] = null;
									continue;
								};/*
								break;
							case "russet golem":
								spawnOffset = 100;
								if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY <= level.rows[i] + 6 && onGround && level.golems[i].riseSpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
									level.golems[i].riseSpeed = -0.01;
									placeFeatureEntity("russet golem", i + spawnOffset, true);
									if (level.golems[i + Math.floor(spawnOffset / 2)] == null)  {
										placeFeatureEntity("golem", i + Math.floor(spawnOffset / 2), true);
									};
								};
								level.golems[i].yOffset += level.golems[i].riseSpeed;
								if (level.golems[i].yOffset > 0) {
									level.golems[i].riseSpeed = 0;
									level.golems[i].yOffset = 0;
								} else if (level.golems[i].yOffset <= -6) {
									level.golems[i] = null;
									continue;
								};
								break;
							case "aqua golem":
								spawnOffset = 10;
								if (i + 1 > playerX - 0.5 && i < playerX + 0.5 && playerY <= level.rows[i] + 9 && onGround && level.golems[i].riseSpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
									level.golems[i].riseSpeed = -0.005;
									placeFeatureEntity("aqua golem", i + spawnOffset, true);
									if (level.golems[i + Math.floor(spawnOffset * (1 / 3))] == null)  {
										placeFeatureEntity("russet golem", i + Math.floor(spawnOffset * (1 / 3)), true);
									};
									if (level.golems[i + Math.floor(spawnOffset * (2 / 3))] == null)  {
										placeFeatureEntity("golem", i + Math.floor(spawnOffset * (2 / 3)), true);
									};
								};
								level.golems[i].yOffset += level.golems[i].riseSpeed;
								if (level.golems[i].yOffset > 0) {
									level.golems[i].riseSpeed = 0;
									level.golems[i].yOffset = 0;
								} else if (level.golems[i].yOffset <= -9) {
									level.golems[i] = null;
									continue;
								};
								break;
							case "mecha golem":
								spawnOffset = 10;
								if (i + 2 > playerX - 0.5 && i - 1 < playerX + 0.5 && playerY <= level.rows[i] + 12 && onGround && level.golems[i].riseSpeed === 0 && level.golems[i + spawnOffset] === null && boots !== "tennis rackets") {
									level.golems[i].riseSpeed = -0.01;
									placeFeatureEntity("mecha golem", i + spawnOffset, true);
									if (level.golems[i + Math.floor(spawnOffset * (1 / 4))] === null)  {
										placeFeatureEntity("aqua golem", i + Math.floor(spawnOffset * (1 / 4)), true);
									};
									if (level.golems[i + Math.floor(spawnOffset * (2 / 4))] === null)  {
										placeFeatureEntity("russet golem", i + Math.floor(spawnOffset * (2 / 4)), true);
									};
									if (level.golems[i + Math.floor(spawnOffset * (3 / 4))] === null)  {
										placeFeatureEntity("golem", i + Math.floor(spawnOffset * (3 / 4)), true);
									};
								};
								level.golems[i].yOffset += level.golems[i].riseSpeed;
								if (level.golems[i].yOffset > 0) {
									level.golems[i].riseSpeed = 0;
									level.golems[i].yOffset = 0;
								} else if (level.golems[i].yOffset <= -12) {
									level.golems[i] = null;
									continue;
								};
								break;
						};*/
					};
				};

				for (let mob of level.mobs) {
					switch (mob.type) {
						case "sentry":
							if (mob.age >= 120) {
								let xSign = Math.sign(playerX - mob.x)
								mob.x += xSign * 0.06;
								if (xSign !== Math.sign(playerX - mob.x)) {
									mob.x = playerX;
								};
								let sentryStepHeight = bakedRows[getHittableRows(mob.x).reduce((a, b) => bakedRows[a] > bakedRows[b] ? a : b)];
								if (sentryStepHeight - (mob.y) <= 3) {
									mob.y = sentryStepHeight;
								} else {
									mob.x = Math.ceil(mob.x) - 0.5;
								};
								if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 4 && playerY + 2 > mob.y) {
									health -= 0.01;
								};
								for (let collisionMob of level.mobs) {
									if (mob.x + 0.5 > collisionMob.x - 0.5 && mob.x - 0.5 < collisionMob.x + 0.5 && collisionMob.y < mob.y + 4 && collisionMob.y + 4 > mob.y && collisionMob.type === "mimic" && !collisionMob.mimicking) {
										placeFeatureEntity("obelisk", Math.floor((mob.x + collisionMob.x) / 2), true);
										level.mobs.splice(level.mobs.indexOf(mob));
										level.mobs.splice(level.mobs.indexOf(collisionMob));
									};
								};
							};
							break;
						case "mimic":
							if (!mob.mimicking) {
								mob.x = (mob.x > playerX ? Math.min : Math.max)(mob.x, mob.x + playerXV);
								mob.y = bakedRows[getHittableRows(mob.x).reduce((a, b) => bakedRows[a] > bakedRows[b] ? a : b)];
								if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 4 && playerY + 2 > mob.y) {
									health -= 0.01;
								};
							} else if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 1 && playerY + 2 > mob.y && dybbukTime <= 0) {
								mob.mimicTimer = true;
							};
							if (mob.mimicTimer) {
								mob.mimicSpawnAge++;
								mob.mimicking = (mob.mimicSpawnAge < 120);
							};
							if (mob.mimicSpawnAge - 120 >= 1800) {
								if (level.features[Math.floor(mob.x)] === 0) {
									level.features[Math.floor(mob.x)] = {"coin": 1, "gem": 2}[mob.mimicTarget];
								};
								level.mobs.splice(level.mobs.indexOf(mob));
							};
							break;
						case "leprechaun":
							mob.x += 0.15//(playerX - 1.5) / (gameTime * 60);
							mob.y = bakedRows[getHittableRows(mob.x).reduce((a, b) => bakedRows[a] > bakedRows[b] ? a : b)];
							if (mob.x + 0.5 > playerX - 0.5 && mob.x - 0.5 < playerX + 0.5 && playerY < mob.y + 1.5 && playerY + 2 > mob.y) {
								let rainbowSize = 100;
								level.terrainFeatures[Math.floor(mob.x - rainbowSize)] = "rainbow";
								level.features[Math.floor(mob.x - rainbowSize)] = 14;
								level.mobs.splice(level.mobs.indexOf(mob));
							};
					};
					mob.age++;
				};

				cameraX = lerp(cameraX, (playerX * blockSize - canvas.width / 2), 0.25);
				cameraY = lerp(cameraY, ((playerY + 1) * -blockSize - canvas.height / 2), 0.25);
				score = Math.max(score, Math.floor(playerX));
				pb = Math.max(pb, score);

				health += potions["regeneration potion"].time > 0 ? 0.0008 : -0.00008;
				health = clamp(health, 0, maxHealth);
				dead = health <= 0;
				notificationTime = Math.max(0, notificationTime - 1);


				// draw screen vv


				ctx.clearRect(0, 0, canvas.width, canvas.height);

				images[((gameTime % 600 < 300 && getLayer(playerY) < 4) ? "skyDay" : "skyNight")].draw(0, 0, canvas.width, canvas.height);
				
				if (cameraY > 200) {
					images.stoneBackground.draw(Math.mod(-cameraX, canvas.width * 4) / 4,					Math.mod(-cameraY, canvas.height * 4) / 4,					canvas.width, canvas.height);
					images.stoneBackground.draw(Math.mod(-cameraX, canvas.width * 4) / 4 - canvas.width,	Math.mod(-cameraY, canvas.height * 4) / 4,					canvas.width, canvas.height);
					images.stoneBackground.draw(Math.mod(-cameraX, canvas.width * 4) / 4,					Math.mod(-cameraY, canvas.height * 4) / 4 - canvas.height,	canvas.width, canvas.height);
					images.stoneBackground.draw(Math.mod(-cameraX, canvas.width * 4) / 4 - canvas.width,	Math.mod(-cameraY, canvas.height * 4) / 4 - canvas.height,	canvas.width, canvas.height);
				};
				
				images.hills.draw(0, 200, images.hills.width, images.hills.height - 200, Math.mod(-cameraX, canvas.width * 4) / 4, (200 - cameraY) / 4, canvas.width, canvas.height);
				images.hills.draw(0, 200, images.hills.width, images.hills.height - 200, Math.mod(-cameraX, canvas.width * 4) / 4 - canvas.width, (200 - cameraY) / 4, canvas.width, canvas.height);

				for (let i = 0; i < level.terrainFeatures.length; i++) {
					if (level.terrainFeatures[i] === "rainbow") {
						let rainbowSize = 100;
						images.rainbow.draw(i * blockSize - cameraX, (level.rows[i] + rainbowSize / 2) * -blockSize - cameraY, blockSize * rainbowSize, blockSize * rainbowSize);
					};
				};

				// grass
				let rowBuffer = Object.keys(level.rows).filter(it => it * blockSize + blockSize > cameraX && it * blockSize < cameraX + canvas.width);
				for (let i = 0; i < rowBuffer.length; i++) {
					let ice = getLayer(level.rows[rowBuffer[i]]) === 2 && Math.round((level.rows[rowBuffer[i]] - 200) * 1000) / 1000 <= Math.round((level.originalRows[rowBuffer[i]] - 200) * 0.9 * 1000) / 1000;
					let groundImage = ice ? images.packedSnow : layers[clamp(getLayer(level.rows[rowBuffer[i]]), Math.min(...Object.keys(layers)), Math.max(...Object.keys(layers)))][0];
					let blockUVSize = groundImage.width / (25 * (resizeGroundUV ? (50 / blockSize) : 1));
					let waterUVSize = images.water.width / (25 * (resizeGroundUV ? (50 / blockSize) : 1));
					let rowY = level.rows[rowBuffer[i]] * -blockSize - cameraY;
					groundImage.draw((blockUVSize * rowBuffer[i]) % (Math.floor(groundImage.width / blockUVSize) * blockUVSize), 0, blockUVSize, groundImage.height, rowBuffer[i] * blockSize - cameraX, rowY, blockSize, blockSize * (groundImage.height / blockUVSize));
					if (level.waterLevel[rowBuffer[i]] > 0) {
						ctx.globalAlpha = 0.5;
						images.water.draw((waterUVSize * rowBuffer[i]) % (Math.floor(images.water.width / waterUVSize) * waterUVSize), 0, waterUVSize, images.water.height, rowBuffer[i] * blockSize - cameraX, (level.rows[rowBuffer[i]] + level.waterLevel[rowBuffer[i]]) * -blockSize - cameraY, blockSize, level.waterLevel[rowBuffer[i]] * blockSize);
						ctx.globalAlpha = 1
					};
					switch (level.features[rowBuffer[i]]) {
						case 0:
							break;
						case 1:
							images.coin.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 2:
							images.gem.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 3:
							images.ladder.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 4, blockSize, blockSize * 4);
							break;
						case 4:
							images.ladder.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 6, blockSize, blockSize * 6);
							break;
						case 5:
							images.stones.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 5, blockSize, blockSize * 5);
							break;
						case 6:
							images.mysteryCrate.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 7:
							images.sentryBarracks.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 3, blockSize, blockSize * 3);
							break;
						case 8:
							images.sentryBarracks.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 3, blockSize, blockSize * 3);
							break;
						case 9:
							images.pitfall.draw(rowBuffer[i] * blockSize - cameraX, rowY, blockSize, blockSize * 0.5);
							break;
						case 10:
							images.dybbukBox.draw(110, 75, 200, 250, rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 11:
							images.dybbukBoxOpen.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 12:
							images.totem.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 13:
							images.fourLeafClover.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 14:
							images.potOfGold.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 15:
							images.burlapSack.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
							break;
						case 16:
							images.ruinedObelisk.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 4, blockSize, blockSize * 4);
							break;
						default:
							images.error.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
					};
					let featureEntity = level.featureEntities[rowBuffer[i]];
					if (featureEntity) {
						switch (featureEntity.type) {
							case "obelisk":
								images.obelisk.draw(875, 50, 200, 730 - (featureEntity.yOffset * -blockSize * (730 / (blockSize * 4))), rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 4 - featureEntity.yOffset * blockSize, blockSize, blockSize * 4 - featureEntity.yOffset * -blockSize);
								break;
							default:
								images.error.draw(rowBuffer[i] * blockSize - cameraX, rowY - blockSize, blockSize, blockSize);
						};
					};
					let golem = level.golems[rowBuffer[i]];
					if (golem) {
						switch (golem.type) {
							case "golem":
								images.golem.draw(0, 0, 1670, 1837 - (golem.yOffset * -blockSize * (1830 / (blockSize * 3))), rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 3 - golem.yOffset * blockSize, blockSize, blockSize * 3 - golem.yOffset * -blockSize);
								break;
							case "russet golem":
								images.russetGolem.draw(0, 0, 570, 570 - (golem.yOffset * -blockSize * (570 / (blockSize * 6))), rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 6 - golem.yOffset * blockSize, blockSize, blockSize * 6 - golem.yOffset * -blockSize);
								break;
							case "aqua golem":
								images.aquaGolem.draw(200, 70, 450, 705 - (golem.yOffset * -blockSize * (705 / (blockSize * 9))), rowBuffer[i] * blockSize - cameraX, rowY - blockSize * 9 - golem.yOffset * blockSize, blockSize, blockSize * 9 - golem.yOffset * -blockSize);
								break;
							case "mecha golem":
								images.mechaGolem.draw(300, 0, 350, 600 - (golem.yOffset * -blockSize * (600 / (blockSize * 12))), (rowBuffer[i] - 1) * blockSize - cameraX, rowY - blockSize * 12 - golem.yOffset * blockSize, blockSize * 3, blockSize * 12 - golem.yOffset * -blockSize);
								break;
						};
					};
				};
			
				let animatedGuyImage = dead ? "guyDead" : (inLadder ? "guyClimbingLadder" : (flying ? "guyFlying" : (onGround ? (Math.abs(playerXV) > 0.1 ? "guyRunning" : "guy") : (playerYV <= 0 ? "guyFalling" : "guyJumping"))));
				images[document.getElementById("animations-checkbox").checked ? animatedGuyImage : "guy"].draw(playerX * blockSize - blockSize / 2 - cameraX, playerY * -blockSize - blockSize * 2 - cameraY, blockSize, blockSize * 2);
				if (dybbukTime > 0) {
					ctx.globalAlpha = 0.5;
					images.dybbuk.draw(playerX * blockSize - blockSize / 2 - cameraX, playerY * -blockSize - blockSize * 2 - cameraY, blockSize, blockSize * 2);
					ctx.globalAlpha = 1;
				};
				let grimReaperX = lerp(playerX - 1, playerX - 100, health / maxHealth);
				images.grimReaper.draw((grimReaperX - 0.5) * blockSize - cameraX, (bakedRows[getHittableRows(grimReaperX).reduce((a, b) => bakedRows[a] > bakedRows[b] ? a : b)] + 3) * -blockSize - cameraY, blockSize, blockSize * 3);

				for (let mob of level.mobs) {if (mob.x * blockSize + blockSize / 2 - cameraX > 0 && mob.x * blockSize - blockSize / 2 - cameraX < canvas.width) {
						switch (mob.type) {
							case "sentry":
								if (mob.age >= 120) {
									images.sentry.draw(mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize * 4 - cameraY, blockSize, blockSize * 4);
								};
								break;
							case "mimic":
								if (mob.mimicking) {
									switch (mob.mimicTarget) {
										case "coin":
											images.coin.draw(mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize - cameraY, blockSize, blockSize);
											break;
										case "gem":
											images.gem.draw(mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize - cameraY, blockSize, blockSize);
											break;
										default:
											images.error.draw(mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize - cameraY, blockSize, blockSize);
									};
								} else {
									switch (Math.sign(Math.round(playerXV * 1000) / 1000)) {
										case -1:
											images.mimic.draw(307, 87, 84, 193, mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize * 4 - cameraY, blockSize, blockSize * 4);
											break;
										case 0:
											images.mimic.draw(217, 91, 95, 198, mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize * 4 - cameraY, blockSize, blockSize * 4);
											break;
										case 1:
											images.mimic.draw(109, 91, 95, 198, mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize * 4 - cameraY, blockSize, blockSize * 4);
									};
								};
								break;
							case "leprechaun":
								images.leprechaun.draw(mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize * 1.5 - cameraY, blockSize, blockSize * 1.5);
								break;
							default:
								images.error.draw(mob.x * blockSize - blockSize / 2 - cameraX, mob.y * -blockSize - blockSize * 2 - cameraY, blockSize, blockSize * 2);
						};
					};
				};
				let darknessOpacity = (Math.max(Math.sin((gameTime - 300) / (300 / Math.PI)), 0) ** 2);
				ctx.fillStyle = "rgba(0, 0, 0, " + darknessOpacity + ")";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.font = "30px arial";
				ctx.fillStyle = "yellow";
				if (facasd) {
					ctx.fillText("Marina silva is a brazilian politician and an activist for deforestation and other things.", 0, 300);
					ctx.fillText("She was a rubber tapper and found that land was being invaded by rubber tappers and she", 0, 325);
					ctx.fillText("started protecting thousands of hectares of land.", 0, 350);
				};
			};
			let healthPercent = health / maxHealth
			let r = clamp(2 - healthPercent * 2, 0, 1) * 255;
			let g = clamp(healthPercent * 2, 0, 1) * 255;
			let b = (potions["regeneration potion"].time > 0) * 127;
			document.getElementById("health").style.width = 600 * (maxHealth / 1) + "px";
			document.getElementById("health-inner").style.width = 600 * health + "px";
			document.getElementById("health-inner").style.backgroundColor = "rgb(" + r + ", " + g + ", " + b + ")";
			if (dead) {
				ctx.font = "100px arial";
				ctx.fillStyle = "red";
				ctx.fillText("you died", 200, 200);
			};
			document.getElementById("stats").innerHTML = "score: " + score + "<br>elevation: " + Math.floor(playerY) + "<br>coins: " + coins + "<br>gems: " + gems + "<br>totems: " + totems + "<br>boots: " + boots + "<br>fps: " + fps + "<br>net player speed: " + (playerX - 1.5) / (gameTime * 60);
			document.getElementById("notification").innerHTML = notificationTime > 0 ? notification : "";
			for (let food in foods) {
				document.getElementById(food.replaceAll(" ", "-") + "-howmany").innerHTML = "(" + foods[food].howmany + ")";
			};
			for (let potion in potions) {
				document.getElementById(potion.replaceAll(" ", "-") + "-howmany").innerHTML = "(" + potions[potion].howmany + ")";
			};
			document.getElementById("ladder-howmany").innerHTML = "(" + ladders + ")";
			document.getElementById("tall-ladder-howmany").innerHTML = "(" + tallLadders + ")";
		};
		var bobxv = 0;
		function loop() {
			//try {
				tick();
			//} catch (e) {
			//	alert(e.stack);
			//	return;
			//};
			frameCount++;
			let now = performance.now();
			if (Math.floor(fpsUpdateTime / 1000) !== Math.floor(now / 1000)) {
				fpsUpdateTime = now;
				fps = frameCount;
				frameCount = 0;
			};
			requestAnimationFrame(loop);
		};
		loop();
		ctx.font = "100px arial";
		ctx.fillText("loading textures", 100, 100);
	</script>
</html>
